diff --git a/hls-refactor-plugin.cabal b/hls-refactor-plugin.cabal
index 8656d80fb3..7678c360c1 100644
--- a/hls-refactor-plugin.cabal
+++ b/hls-refactor-plugin.cabal
@@ -22,11 +22,6 @@
     location: https://github.com/haskell/haskell-language-server.git
 
 library
-  -- Plugins that need exactprint have not been updated for 9.8 yet
-  if impl(ghc >= 9.8)
-    buildable: False
-  else
-    buildable: True
   exposed-modules:  Development.IDE.GHC.ExactPrint
                     Development.IDE.GHC.Compat.ExactPrint
                     Development.IDE.Plugin.CodeAction
@@ -98,10 +93,6 @@
   default-language: Haskell2010
 
 test-suite tests
-  if impl(ghc >= 9.8)
-    buildable: False
-  else
-    buildable: True
   type:             exitcode-stdio-1.0
   default-language: Haskell2010
   hs-source-dirs:   test
diff --git a/src/Development/IDE/GHC/Dump.hs b/src/Development/IDE/GHC/Dump.hs
index 1d74197445..b19b972feb 100644
--- a/src/Development/IDE/GHC/Dump.hs
+++ b/src/Development/IDE/GHC/Dump.hs
@@ -123,7 +123,11 @@ showAstDataHtml a0 = html $
 
             sourceText :: SourceText -> SDoc
             sourceText NoSourceText     = text "NoSourceText"
+#if MIN_VERSION_ghc(9,7,0)
+            sourceText (SourceText src) = text "SourceText" <+> ftext src
+#else
             sourceText (SourceText src) = text "SourceText" <+> text src
+#endif
 
             epaAnchor :: EpaLocation -> SDoc
 #if MIN_VERSION_ghc(9,5,0)
diff --git a/src/Development/IDE/Plugin/CodeAction.hs b/src/Development/IDE/Plugin/CodeAction.hs
index 8479d5803d..48c33ea07b 100644
--- a/src/Development/IDE/Plugin/CodeAction.hs
+++ b/src/Development/IDE/Plugin/CodeAction.hs
@@ -938,7 +938,11 @@ suggestExtendImport :: ExportsMap -> ParsedSource -> Diagnostic -> [(T.Text, Cod
 suggestExtendImport exportsMap (L _ HsModule {hsmodImports}) Diagnostic{_range=_range,..}
     | Just [binding, mod, srcspan] <-
       matchRegexUnifySpaces _message
+#if MIN_VERSION_ghc(9,7,0)
+      "Add ‘([^’]*)’ to the import list in the import of ‘([^’]*)’ *\\(at (.*)\\)."
+#else
       "Perhaps you want to add ‘([^’]*)’ to the import list in the import of ‘([^’]*)’ *\\((.*)\\)."
+#endif
     = suggestions hsmodImports binding mod srcspan
     | Just (binding, mod_srcspan) <-
       matchRegExMultipleImports _message
@@ -965,9 +969,13 @@ suggestExtendImport exportsMap (L _ HsModule {hsmodImports}) Diagnostic{_range=_
           | otherwise = []
         lookupExportMap binding mod
           | let em = getExportsMap exportsMap
+#if MIN_VERSION_ghc(9,7,0)
+                match = mconcat $ lookupOccEnv_AllNameSpaces em (mkVarOrDataOcc binding)
+#else
                 match1 = lookupOccEnv em (mkVarOrDataOcc binding)
                 match2 = lookupOccEnv em (mkTypeOcc binding)
           , Just match <- match1 <> match2
+#endif
           -- Only for the situation that data constructor name is same as type constructor name,
           -- let ident with parent be in front of the one without.
           , sortedMatch <- sortBy (\ident1 ident2 -> parent ident2 `compare` parent ident1) (Set.toList match)
@@ -1165,9 +1173,20 @@ suggestFixConstructorImport Diagnostic{_range=_range,..}
     -- import Data.Aeson.Types( Result( Success ) )
     -- or
     -- import Data.Aeson.Types( Result(..) ) (lsp-ui)
+    --
+    -- On 9.8+
+    --
+    -- In the import of ‘ModuleA’:
+    -- an item called ‘Constructor’
+    -- is exported, but it is a data constructor of
+    -- ‘A’.
   | Just [constructor, typ] <-
     matchRegexUnifySpaces _message
+#if MIN_VERSION_ghc(9,7,0)
+    "an item called ‘([^’]*)’ is exported, but it is a data constructor of ‘([^’]*)’"
+#else
     "‘([^’]*)’ is a data constructor of ‘([^’]*)’ To import it use"
+#endif
   = let fixedImport = typ <> "(" <> constructor <> ")"
     in [("Fix import of " <> fixedImport, TextEdit _range fixedImport)]
   | otherwise = []
@@ -1434,7 +1453,11 @@ suggestNewImport df packageExportsMap ps fileContents Diagnostic{..}
             *> extractQualifiedModuleNameFromMissingName (extractTextInRange _range fileContents)
   , Just (range, indent) <- newImportInsertRange ps fileContents
   , extendImportSuggestions <- matchRegexUnifySpaces msg
+#if MIN_VERSION_ghc(9,7,0)
+    "Add ‘[^’]*’ to the import list in the import of ‘([^’]*)’"
+#else
     "Perhaps you want to add ‘[^’]*’ to the import list in the import of ‘([^’]*)’"
+#endif
   = let qis = qualifiedImportStyle df
         -- FIXME: we can use thingMissing once the support for GHC 9.4 is dropped.
         -- In what fllows, @missing@ is assumed to be qualified name.
@@ -1952,30 +1975,32 @@ regexSingleMatch msg regex = case matchRegexUnifySpaces msg regex of
     Just (h:_) -> Just h
     _          -> Nothing
 
--- | Parses tuples like (‘Data.Map’, (app/ModuleB.hs:2:1-18)) and
--- | return (Data.Map, app/ModuleB.hs:2:1-18)
-regExPair :: (T.Text, T.Text) -> Maybe (T.Text, T.Text)
-regExPair (modname, srcpair) = do
-  x <- regexSingleMatch modname "‘([^’]*)’"
-  y <- regexSingleMatch srcpair "\\((.*)\\)"
-  return (x, y)
-
 -- | Process a list of (module_name, filename:src_span) values
 -- | Eg. [(Data.Map, app/ModuleB.hs:2:1-18), (Data.HashMap.Strict, app/ModuleB.hs:3:1-29)]
 regExImports :: T.Text -> Maybe [(T.Text, T.Text)]
-regExImports msg = result
-  where
-    parts = T.words msg
-    isPrefix = not . T.isPrefixOf "("
-    (mod, srcspan) = partition isPrefix  parts
-    -- check we have matching pairs like (Data.Map, (app/src.hs:1:2-18))
-    result = if length mod == length srcspan then
-               regExPair `traverse` zip mod srcspan
-             else Nothing
+regExImports msg
+    | Just mods' <- allMatchRegex msg "‘([^’]*)’"
+    , Just srcspans' <- allMatchRegex msg
+#if MIN_VERSION_ghc(9,7,0)
+                          "\\(at ([^)]*)\\)"
+#else
+                          "\\(([^)]*)\\)"
+#endif
+    , mods <- [mod | [_,mod] <- mods']
+    , srcspans <- [srcspan | [_,srcspan] <- srcspans']
+      -- check we have matching pairs like (Data.Map, (app/src.hs:1:2-18))
+    , let result = if length mods == length srcspans then
+                   Just (zip mods srcspans) else Nothing
+    = result
+    | otherwise = Nothing
 
 matchRegExMultipleImports :: T.Text -> Maybe (T.Text, [(T.Text, T.Text)])
 matchRegExMultipleImports message = do
+#if MIN_VERSION_ghc(9,7,0)
+  let pat = T.pack "Add ‘([^’]*)’ to one of these import lists: *(‘.*\\))$"
+#else
   let pat = T.pack "Perhaps you want to add ‘([^’]*)’ to one of these import lists: *(‘.*\\))$"
+#endif
   (binding, imports) <- case matchRegexUnifySpaces message pat of
                             Just [x, xs] -> Just (x, xs)
                             _            -> Nothing
diff --git a/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs b/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs
index 4c07354295..10327423e6 100644
--- a/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs
+++ b/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs
@@ -253,7 +253,13 @@ extendImportTopLevel thing (L l it@ImportDecl{..})
                                 noExtField
 #endif
                                 rdr
-        x = reLocA $ L top $ IEVar noExtField lie
+        x = reLocA $ L top $ IEVar
+#if MIN_VERSION_ghc(9,8,0)
+                               Nothing -- no deprecated
+#else
+                               noExtField
+#endif
+                               lie
 
     if x `elem` lies
       then TransformT $ lift (Left $ thing <> " already imported")
@@ -311,7 +317,13 @@ extendImportViaParent df parent child (L l it@ImportDecl{..})
                                              noExtField
 #endif
                                              childRdr
-          x :: LIE GhcPs = L ll' $ IEThingWith (addAnns mempty [AddEpAnn AnnOpenP (EpaDelta (SameLine 1) []), AddEpAnn AnnCloseP def] emptyComments) absIE NoIEWildcard [childLIE]
+          x :: LIE GhcPs = L ll' $ IEThingWith
+#if MIN_VERSION_ghc(9,7,0)
+                                     (Nothing, addAnns mempty [AddEpAnn AnnOpenP (EpaDelta (SameLine 1) []), AddEpAnn AnnCloseP def] emptyComments)
+#else
+                                     (addAnns mempty [AddEpAnn AnnOpenP (EpaDelta (SameLine 1) []), AddEpAnn AnnCloseP def] emptyComments)
+#endif
+                                     absIE NoIEWildcard [childLIE]
 
 #if MIN_VERSION_ghc(9,5,0)
       return $ L l it{ideclImportList = Just (hide, L l' $ reverse pre ++ [x] ++ xs)}
@@ -329,7 +341,11 @@ extendImportViaParent df parent child (L l it@ImportDecl{..})
         let it' = it{ideclHiding = Just (hide, lies)}
 #endif
             thing = IEThingWith newl twIE (IEWildcard 2) []
+#if MIN_VERSION_ghc(9,7,0)
+            newl = fmap (\ann -> ann ++ [(AddEpAnn AnnDotdot d0)]) <$> l'''
+#else
             newl = (\ann -> ann ++ [(AddEpAnn AnnDotdot d0)]) <$> l'''
+#endif
             lies = L l' $ reverse pre ++ [L l'' thing] ++ xs
         return $ L l it'
     | parent == unIEWrappedName ie
@@ -382,7 +398,11 @@ extendImportViaParent df parent child (L l it@ImportDecl{..})
                                              noExtField
 #endif
                                              childRdr
+#if MIN_VERSION_ghc(9,7,0)
+          listAnn = (Nothing, epAnn srcParent [AddEpAnn AnnOpenP (epl 1), AddEpAnn AnnCloseP (epl 0)])
+#else
           listAnn = epAnn srcParent [AddEpAnn AnnOpenP (epl 1), AddEpAnn AnnCloseP (epl 0)]
+#endif
           x :: LIE GhcPs = reLocA $ L l'' $ IEThingWith listAnn parentLIE NoIEWildcard [childLIE]
 
           lies' = addCommaInImportList (reverse pre) x
@@ -486,7 +506,13 @@ extendHiding symbol (L l idecls) mlies df = do
                                noExtField
 #endif
                                rdr
-      x = reLocA $ L top $ IEVar noExtField lie
+      x = reLocA $ L top $ IEVar
+#if MIN_VERSION_ghc(9,7,0)
+                             Nothing
+#else
+                             noExtField
+#endif
+                             lie
   x <- pure $ if hasSibling then first addComma x else x
   lies <- pure $ over _head (`setEntryDP` SameLine 1) lies
 #if MIN_VERSION_ghc(9,5,0)
