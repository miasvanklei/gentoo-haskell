diff --git a/session-loader/Development/IDE/Session.hs b/session-loader/Development/IDE/Session.hs
index dde1cfdea5..cfc5fc9654 100644
--- a/session-loader/Development/IDE/Session.hs
+++ b/session-loader/Development/IDE/Session.hs
@@ -885,7 +885,12 @@ newComponentCache recorder exts _cfp hsc_env old_cis new_cis = do
     hscEnv' <- -- Set up a multi component session with the other units on GHC 9.4
               Compat.initUnits dfs hsc_env
 
+#if MIN_VERSION_ghc(9,13,0)
+    let closure_errs_raw = checkHomeUnitsClosed' (hsc_unit_env hscEnv') (hsc_all_home_unit_ids hscEnv')
+        closure_errs = concatMap (Compat.bagToList . Compat.getMessages) closure_errs_raw
+#else
     let closure_errs = maybeToList $ checkHomeUnitsClosed' (hsc_unit_env hscEnv') (hsc_all_home_unit_ids hscEnv')
+#endif
         closure_err_to_multi_err err =
             ideErrorWithSource
                 (Just "cradle") (Just DiagnosticSeverity_Warning) _cfp
diff --git a/src/Development/IDE/Core/Compile.hs b/src/Development/IDE/Core/Compile.hs
index 48439e2ff3..2806818b9c 100644
--- a/src/Development/IDE/Core/Compile.hs
+++ b/src/Development/IDE/Core/Compile.hs
@@ -149,6 +149,15 @@ import           GHC.Driver.Env                               (hsc_all_home_unit
 import           GHC.Iface.Ext.Types                          (NameEntityInfo)
 #endif
 
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Driver.Env                               (hscInsertHPT, setModuleGraph)
+import           GHC.Unit.Home.Graph                          (UnitEnvGraph(..), unitEnv_assocs)
+import           GHC.Unit.Home.PackageTable                   (hptInternalTableRef, hptInternalTableFromRef)
+import           GHC.Unit.Module.ModIface                     (IfaceTopEnv(..))
+import           GHC.Types.Avail                              (emptyDetOrdAvails)
+import           GHC.Types.Basic                              (ImportLevel(..))
+#endif
+
 #if MIN_VERSION_ghc(9,12,0)
 import           Development.IDE.Import.FindImports
 #endif
@@ -311,7 +320,11 @@ captureSplicesAndDeps TypecheckHelpers{..} env k = do
                                          , moduleUnitId mod `elem` home_unit_ids -- Only care about stuff from the home package set
                                          ]
                  home_unit_ids =
+#if MIN_VERSION_ghc(9,13,0)
+                    map fst (unitEnv_assocs $ hsc_HUG hsc_env)
+#else
                     map fst (hugElts $ hsc_HUG hsc_env)
+#endif
                  mods_transitive = getTransitiveMods hsc_env needed_mods
 
                  -- If we don't support multiple home units, ModuleNames are sufficient because all the units will be the same
@@ -323,7 +336,11 @@ captureSplicesAndDeps TypecheckHelpers{..} env k = do
                                  | installedMod <- mods_transitive_list
                                  , let file = fromJust $ lookupModuleFile (installedMod { moduleUnit = RealUnit (Definite $ moduleUnit installedMod) }) moduleLocs
                                  ]
+#if MIN_VERSION_ghc(9,13,0)
+           ; hsc_env' <- loadModulesHome (map linkableHomeMod lbs) hsc_env
+#else
            ; let hsc_env' = loadModulesHome (map linkableHomeMod lbs) hsc_env
+#endif
 
              {- load it -}
 #if MIN_VERSION_ghc(9,11,0)
@@ -333,7 +350,11 @@ captureSplicesAndDeps TypecheckHelpers{..} env k = do
 #else
            ; (fv_hvs, lbss, pkgs) <- loadDecls (hscInterp hsc_env') hsc_env' srcspan bcos
 #endif
+#if MIN_VERSION_ghc(9,13,0)
+           ; let hval = (expectJust $ lookup (idName binding_id) fv_hvs, lbss, pkgs)
+#else
            ; let hval = (expectJust "hscCompileCoreExpr'" $ lookup (idName binding_id) fv_hvs, lbss, pkgs)
+#endif
 
            ; modifyIORef' var (flip extendModuleEnvList [(mi_module $ hm_iface hm, linkableHash lb) | lb <- lbs, let hm = linkableHomeMod lb])
            ; return hval }
@@ -351,10 +372,19 @@ captureSplicesAndDeps TypecheckHelpers{..} env k = do
 
     -- Compute the transitive set of linkables required
     getTransitiveMods hsc_env needed_mods
+#if MIN_VERSION_ghc(9,13,0)
+      = Set.unions (Set.fromList (map moduleToNodeKey mods) : [ Set.fromList $ map mkNodeKey dep
+                                                              | m <- mods
+                                                              , Just dep <-
+                                                                  [mgReachable (hsc_mod_graph hsc_env) (moduleToNodeKey m)]
+                                                              ])
+      where mods = nonDetEltsUniqSet needed_mods -- OK because we put them into a set immediately after
+#else
       = Set.unions (Set.fromList (map moduleToNodeKey mods) : [ dep | m <- mods
                                                               , Just dep <- [Map.lookup (moduleToNodeKey m) (mgTransDeps (hsc_mod_graph hsc_env))]
                                                               ])
       where mods = nonDetEltsUniqSet needed_mods -- OK because we put them into a set immediately after
+#endif
 
     -- | Add a Hook to the DynFlags which captures and returns the
     -- typechecked splices before they are run. This information
@@ -458,7 +488,9 @@ mkHiFileResultNoCompile session tcm = do
   iface' <- mkIfaceTc hsc_env_tmp sf details ms Nothing tcGblEnv
   -- See Note [Clearing mi_globals after generating an iface]
   let iface = iface'
-#if MIN_VERSION_ghc(9,11,0)
+#if MIN_VERSION_ghc(9,13,0)
+                & set_mi_top_env (IfaceTopEnv emptyDetOrdAvails [])
+#elif MIN_VERSION_ghc(9,11,0)
                 & set_mi_top_env Nothing
                 & set_mi_usages (filterUsages (mi_usages iface'))
 #else
@@ -483,6 +515,14 @@ mkHiFileResultCompile se session' tcm simplified_guts = catchErrs $ do
         (guts, details) <- tidyProgram tidy_opts simplified_guts
         pure (details, guts)
 
+#if MIN_VERSION_ghc(9,13,0)
+  partial_iface <- mkPartialIface session
+                                  (cg_binds guts)
+                                  details
+                                  ms
+                                  (tcg_import_decls (tmrTypechecked tcm))
+                                  simplified_guts
+#else
   let !partial_iface = force $ mkPartialIface session
                                               (cg_binds guts)
                                               details
@@ -491,6 +531,7 @@ mkHiFileResultCompile se session' tcm simplified_guts = catchErrs $ do
                                               (tcg_import_decls (tmrTypechecked tcm))
 #endif
                                               simplified_guts
+#endif
 
   final_iface' <- mkFullIface session partial_iface Nothing
                     Nothing
@@ -499,7 +540,9 @@ mkHiFileResultCompile se session' tcm simplified_guts = catchErrs $ do
 #endif
   -- See Note [Clearing mi_globals after generating an iface]
   let final_iface = final_iface'
-#if MIN_VERSION_ghc(9,11,0)
+#if MIN_VERSION_ghc(9,13,0)
+                      & set_mi_top_env (IfaceTopEnv emptyDetOrdAvails [])
+#elif MIN_VERSION_ghc(9,11,0)
                       & set_mi_top_env Nothing
                       & set_mi_usages (filterUsages (mi_usages final_iface'))
 #else
@@ -532,9 +575,19 @@ mkHiFileResultCompile se session' tcm simplified_guts = catchErrs $ do
       traceIO $ "Verifying " ++ core_fp
       let CgGuts{cg_binds = unprep_binds, cg_tycons = tycons } = guts
           mod = ms_mod ms
-          data_tycons = filter isDataTyCon tycons
+          data_tycons = filter isAlgTyCon tycons
       CgGuts{cg_binds = unprep_binds'} <- coreFileToCgGuts session final_iface details core
       cp_cfg <- initCorePrepConfig session
+#if MIN_VERSION_ghc(9,13,0)
+      let corePrep = corePrepPgm
+                       (hsc_logger session) cp_cfg (initCorePrepPgmConfig (hsc_dflags session) (interactiveInScope $ hsc_IC session))
+                       mod
+
+      -- Run corePrep first as we want to test the final version of the program that will
+      -- get translated to STG/Bytecode
+      prepd_binds
+        <- corePrep unprep_binds
+#else
       let corePrep = corePrepPgm
                        (hsc_logger session) cp_cfg (initCorePrepPgmConfig (hsc_dflags session) (interactiveInScope $ hsc_IC session))
                        mod (ms_location ms)
@@ -543,8 +596,14 @@ mkHiFileResultCompile se session' tcm simplified_guts = catchErrs $ do
       -- get translated to STG/Bytecode
       prepd_binds
         <- corePrep unprep_binds data_tycons
+#endif
+#if MIN_VERSION_ghc(9,13,0)
+      prepd_binds'
+        <- corePrep unprep_binds'
+#else
       prepd_binds'
         <- corePrep unprep_binds' data_tycons
+#endif
       let binds  = noUnfoldings $ (map flattenBinds . (:[])) prepd_binds
           binds' = noUnfoldings $ (map flattenBinds . (:[])) prepd_binds'
 
@@ -987,6 +1046,31 @@ mergeEnvs :: HscEnv
           -> [HscEnv]
           -> IO HscEnv
 mergeEnvs env mg dep_info ms extraMods envs = do
+#if MIN_VERSION_ghc(9,13,0)
+      newHug <- sequence $ foldl' mergeHUG (pure <$> hsc_HUG env) (map (fmap pure . hsc_HUG) envs)
+      let hsc_env' = setModuleGraph mg $ (hscUpdateHUG (const newHug) env){
+                hsc_FC = (hsc_FC env)
+                  { addToFinderCache = \im val ->
+                        if moduleUnit im `elem` hsc_all_home_unit_ids env
+                        then pure ()
+                        else addToFinderCache (hsc_FC env) im val
+                  , lookupFinderCache = \im ->
+                        if moduleUnit im `elem` hsc_all_home_unit_ids env
+                        then case lookupModuleFile (im { moduleUnit = RealUnit (Definite $ moduleUnit im) }) dep_info of
+                               Nothing -> pure Nothing
+                               Just fs -> let ml = fromJust $ do
+                                                    id <- lookupPathToId (depPathIdMap dep_info) fs
+                                                    artifactModLocation (idToModLocation (depPathIdMap dep_info) id)
+#if MIN_VERSION_ghc(9,13,0)
+                                          in pure $ Just $ InstalledFound ml
+#else
+                                          in pure $ Just $ InstalledFound ml im
+#endif
+                        else lookupFinderCache (hsc_FC env) im
+                  }
+            }
+      loadModulesHome extraMods hsc_env'
+#else
     return $! loadModulesHome extraMods $
       let newHug = foldl' mergeHUG (hsc_HUG env) (map hsc_HUG envs) in
       (hscUpdateHUG (const newHug) env){
@@ -1007,8 +1091,23 @@ mergeEnvs env mg dep_info ms extraMods envs = do
                   else lookupFinderCache (hsc_FC env) gwib
             }
       }
+#endif
 
     where
+#if MIN_VERSION_ghc(9,13,0)
+        mergeHUG :: UnitEnvGraph (IO HomeUnitEnv) -> UnitEnvGraph (IO HomeUnitEnv) -> UnitEnvGraph (IO HomeUnitEnv)
+        mergeHUG (UnitEnvGraph a) (UnitEnvGraph b) = UnitEnvGraph $ Map.unionWith mergeHUE a b
+        mergeHUE a b = do
+          a_v <- a
+          hpt_b <- readIORef . hptInternalTableRef . homeUnitEnv_hpt =<< b
+          hpt_a <- readIORef . hptInternalTableRef . homeUnitEnv_hpt $ a_v
+          result <- hptInternalTableFromRef =<< (newIORef $! mergeUDFM hpt_a hpt_b)
+          return $! a_v { homeUnitEnv_hpt = result }
+        mergeUDFM = plusUDFM_C combineModules
+        combineModules a b
+          | HsSrcFile <- mi_hsc_src (hm_iface a) = a
+          | otherwise = b
+#else
         mergeHUG (UnitEnvGraph a) (UnitEnvGraph b) = UnitEnvGraph $ Map.unionWith mergeHUE a b
         mergeHUE a b = a { homeUnitEnv_hpt = mergeUDFM (homeUnitEnv_hpt a) (homeUnitEnv_hpt b) }
         mergeUDFM = plusUDFM_C combineModules
@@ -1016,6 +1115,7 @@ mergeEnvs env mg dep_info ms extraMods envs = do
         combineModules a b
           | HsSrcFile <- mi_hsc_src (hm_iface a) = a
           | otherwise = b
+#endif
 
 #else
 mergeEnvs :: HscEnv
@@ -1112,8 +1212,14 @@ getModSummaryFromImports env fp _modTime mContents = do
 
         rn_pkg_qual = renameRawPkgQual (hsc_unit_env ppEnv)
         rn_imps = fmap (\(pk, lmn@(L _ mn)) -> (rn_pkg_qual mn pk, lmn))
+#if MIN_VERSION_ghc(9,13,0)
+        -- In GHC 9.13+, ms_srcimps is just [Located ModuleName] and ms_textual_imps includes ImportLevel
+        srcImports = map snd $ rn_imps $ map convImport src_idecls
+        textualImports = map (\(pk, lmn) -> (NormalLevel, pk, lmn)) $ rn_imps $ map convImport (implicit_imports ++ ordinary_imps)
+#else
         srcImports = rn_imps $ map convImport src_idecls
         textualImports = rn_imps $ map convImport (implicit_imports ++ ordinary_imps)
+#endif
         ghc_prim_import = not (null _ghc_prim_imports)
 
 
@@ -1135,7 +1241,9 @@ getModSummaryFromImports env fp _modTime mContents = do
                 { ms_mod          = modl
                 , ms_hie_date     = Nothing
                 , ms_dyn_obj_date    = Nothing
+#if !MIN_VERSION_ghc(9,13,0)
                 , ms_ghc_prim_import = ghc_prim_import
+#endif
                 , ms_hs_hash      = _src_hash
 
                 , ms_hsc_src      = sourceType
@@ -1160,12 +1268,24 @@ getModSummaryFromImports env fp _modTime mContents = do
         computeFingerprint opts ModSummary{..} = do
             fingerPrintImports <- fingerprintFromPut $ do
                   put $ Util.uniq $ moduleNameFS $ moduleName ms_mod
+#if MIN_VERSION_ghc(9,13,0)
+                  -- In GHC 9.13+, ms_srcimps is [Located ModuleName] and ms_textual_imps is [(ImportLevel, PkgQual, Located ModuleName)]
+                  forM_ ms_srcimps $ \m -> do
+                    put $ Util.uniq $ moduleNameFS $ unLoc m
+                  forM_ ms_textual_imps $ \(_lvl, mb_p, m) -> do
+                    put $ Util.uniq $ moduleNameFS $ unLoc m
+                    case mb_p of
+                      G.NoPkgQual    -> pure ()
+                      G.ThisPkg uid  -> put $ getKey $ getUnique uid
+                      G.OtherPkg uid -> put $ getKey $ getUnique uid
+#else
                   forM_ (ms_srcimps ++ ms_textual_imps) $ \(mb_p, m) -> do
                     put $ Util.uniq $ moduleNameFS $ unLoc m
                     case mb_p of
                       G.NoPkgQual    -> pure ()
                       G.ThisPkg uid  -> put $ getKey $ getUnique uid
                       G.OtherPkg uid -> put $ getKey $ getUnique uid
+#endif
             return $! Util.fingerprintFingerprints $
                     [ Util.fingerprintString fp
                     , fingerPrintImports
@@ -1421,7 +1541,11 @@ loadInterface session ms linkableNeeded RecompilationInfo{..} = do
         -- ncu and read_dflags are only used in GHC >= 9.4
         let _ncu = hsc_NC sessionWithMsDynFlags
             _read_dflags = hsc_dflags sessionWithMsDynFlags
+#if MIN_VERSION_ghc(9,13,0)
+        read_result <- liftIO $ readIface (hsc_hooks sessionWithMsDynFlags) (hsc_logger sessionWithMsDynFlags) _read_dflags _ncu mod iface_file
+#else
         read_result <- liftIO $ readIface _read_dflags _ncu mod iface_file
+#endif
         case read_result of
           Util.Failed{}        -> return Nothing
           -- important to call `shareUsages` here before checkOldIface
@@ -1445,9 +1569,13 @@ loadInterface session ms linkableNeeded RecompilationInfo{..} = do
       (Just iface, UpToDate) -> do
              details <- liftIO $ mkDetailsFromIface sessionWithMsDynFlags iface
              -- parse the runtime dependencies from the annotations
-             let runtime_deps
-                   | not (mi_used_th iface) = emptyModuleEnv
-                   | otherwise = parseRuntimeDeps (md_anns details)
+             let runtime_deps =
+#if MIN_VERSION_ghc(9,13,0)
+                   parseRuntimeDeps (md_anns details)
+#else
+                   if not (mi_used_th iface) then emptyModuleEnv
+                   else parseRuntimeDeps (md_anns details)
+#endif
              -- Peform the fine grained recompilation check for TH
              maybe_recomp <- checkLinkableDependencies get_linkable_hashes get_module_graph runtime_deps
              case maybe_recomp of
@@ -1517,18 +1645,30 @@ showReason (NeedsRecompile s)           = printWithoutUniques s
 mkDetailsFromIface :: HscEnv -> ModIface -> IO ModDetails
 mkDetailsFromIface session iface = do
   fixIO $ \details -> do
+#if MIN_VERSION_ghc(9,13,0)
+    hscInsertHPT (HomeModInfo iface details emptyHomeModInfoLinkable) session
+    initIfaceLoad session (typecheckIface iface)
+#else
     let !hsc' = hscUpdateHPT (\hpt -> addToHpt hpt (moduleName $ mi_module iface) (HomeModInfo iface details emptyHomeModInfoLinkable)) session
     initIfaceLoad hsc' (typecheckIface iface)
+#endif
 
 coreFileToCgGuts :: HscEnv -> ModIface -> ModDetails -> CoreFile -> IO CgGuts
 coreFileToCgGuts session iface details core_file = do
+  let this_mod = mi_module iface
+  types_var <- newIORef (md_types details)
+#if MIN_VERSION_ghc(9,13,0)
+  let hsc_env' = session {
+        hsc_type_env_vars = knotVarsFromModuleEnv (mkModuleEnv [(this_mod, types_var)])
+        }
+  hscInsertHPT (HomeModInfo iface details emptyHomeModInfoLinkable) hsc_env'
+#else
   let act hpt = addToHpt hpt (moduleName this_mod)
                              (HomeModInfo iface details emptyHomeModInfoLinkable)
-      this_mod = mi_module iface
-  types_var <- newIORef (md_types details)
-  let hsc_env' = hscUpdateHPT act (session {
+      hsc_env' = hscUpdateHPT act (session {
         hsc_type_env_vars = knotVarsFromModuleEnv (mkModuleEnv [(this_mod, types_var)])
         })
+#endif
   core_binds <- initIfaceCheck (text "l") hsc_env' $ typecheckCoreFile this_mod types_var core_file
       -- Implicit binds aren't saved, so we need to regenerate them ourselves.
   let _implicit_binds = concatMap getImplicitBinds tyCons -- only used if GHC < 9.6
@@ -1615,7 +1755,15 @@ pathToModuleName = mkModuleName . map rep
 -- error out when we don't find it
 setNonHomeFCHook :: HscEnv -> HscEnv
 setNonHomeFCHook hsc_env =
-#if MIN_VERSION_ghc(9,11,0)
+#if MIN_VERSION_ghc(9,13,0)
+  hsc_env { hsc_FC = (hsc_FC hsc_env)
+                        { lookupFinderCache = \im ->
+                            if moduleUnit im `elem` hsc_all_home_unit_ids hsc_env
+                            then pure (Just $ InstalledNotFound [] Nothing)
+                            else lookupFinderCache (hsc_FC hsc_env) im
+                        }
+          }
+#elif MIN_VERSION_ghc(9,11,0)
   hsc_env { hsc_FC = (hsc_FC hsc_env)
                         { lookupFinderCache = \m@(GWIB im _) ->
                             if moduleUnit im `elem` hsc_all_home_unit_ids hsc_env
diff --git a/src/Development/IDE/Core/Preprocessor.hs b/src/Development/IDE/Core/Preprocessor.hs
index b3614d89ad..22e7b8a344 100644
--- a/src/Development/IDE/Core/Preprocessor.hs
+++ b/src/Development/IDE/Core/Preprocessor.hs
@@ -30,6 +30,9 @@ import           Development.IDE.Types.Location
 import qualified GHC.LanguageExtensions            as LangExt
 import qualified GHC.Runtime.Loader                as Loader
 import           GHC.Utils.Logger                  (LogFlags (..))
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Driver.Config.Parser          (supportedLanguagePragmas)
+#endif
 import           System.FilePath
 import           System.IO.Extra
 
@@ -144,12 +147,21 @@ parsePragmasIntoHscEnv
     -> Util.StringBuffer
     -> IO (Either [FileDiagnostic] ([String], HscEnv))
 parsePragmasIntoHscEnv env fp contents = catchSrcErrors dflags0 "pragmas" $ do
+#if MIN_VERSION_ghc(9,13,0)
+    let supportedExts = supportedLanguagePragmas dflags0
+    let (_warns,opts) = getOptions (initParserOpts dflags0) supportedExts contents fp
+#else
     let (_warns,opts) = getOptions (initParserOpts dflags0) contents fp
+#endif
 
     -- Force bits that might keep the dflags and stringBuffer alive unnecessarily
     evaluate $ rnf opts
 
+#if MIN_VERSION_ghc(9,13,0)
+    (dflags, _, _) <- parseDynamicFilePragma (hsc_logger env) dflags0 opts
+#else
     (dflags, _, _) <- parseDynamicFilePragma dflags0 opts
+#endif
     hsc_env' <- Loader.initializePlugins (hscSetFlags dflags env)
     return (map unLoc opts, hscSetFlags (disableWarningsAsErrors $ hsc_dflags hsc_env') hsc_env')
   where dflags0 = hsc_dflags env
diff --git a/src/Development/IDE/Core/Rules.hs b/src/Development/IDE/Core/Rules.hs
index 1e050d57b1..9825e135d7 100644
--- a/src/Development/IDE/Core/Rules.hs
+++ b/src/Development/IDE/Core/Rules.hs
@@ -141,6 +141,10 @@ import qualified Development.IDE.Types.Shake                  as Shake
 import           GHC.Iface.Ext.Types                          (HieASTs (..))
 import           GHC.Iface.Ext.Utils                          (generateReferencesMap)
 import qualified GHC.LanguageExtensions                       as LangExt
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Types.PkgQual                            (PkgQual (NoPkgQual))
+import           GHC.Types.Basic                              (ImportLevel (NormalLevel))
+#endif
 import           HIE.Bios.Ghc.Gap                             (hostIsDynamic)
 import qualified HieDb
 import           Ide.Logger                                   (Pretty (pretty),
@@ -315,7 +319,12 @@ getLocatedImportsRule recorder =
     define (cmapWithPrio LogShake recorder) $ \GetLocatedImports file -> do
         ModSummaryResult{msrModSummary = ms} <- use_ GetModSummaryWithoutTimestamps file
         (KnownTargets targets targetsMap) <- useNoFile_ GetKnownTargets
+#if MIN_VERSION_ghc(9,13,0)
+        let imports = [(False, lvl, mbPkgName, modName) | (lvl, mbPkgName, modName) <- ms_textual_imps ms]
+                   ++ [(True, NormalLevel, NoPkgQual, noLoc modName) | L _ modName <- ms_srcimps ms]
+#else
         let imports = [(False, imp) | imp <- ms_textual_imps ms] ++ [(True, imp) | imp <- ms_srcimps ms]
+#endif
         env_eq <- use_ GhcSession file
         let env = hscEnv env_eq
         let import_dirs = map (second homeUnitEnv_dflags) $ hugElts $ hsc_HUG env
@@ -335,7 +344,11 @@ getLocatedImportsRule recorder =
                 | otherwise = do
                     itExists <- getFileExists nfp
                     return $ if itExists then Just nfp else Nothing
+#if MIN_VERSION_ghc(9,13,0)
+        (diags, imports') <- fmap unzip $ forM imports $ \(isSource, _lvl, mbPkgName, modName) -> do
+#else
         (diags, imports') <- fmap unzip $ forM imports $ \(isSource, (mbPkgName, modName)) -> do
+#endif
             diagOrImp <- locateModule (hscSetFlags dflags env) import_dirs (optExtensions opt) getTargetFor modName mbPkgName isSource
             case diagOrImp of
                 Left diags              -> pure (diags, Just (modName, Nothing))
@@ -635,10 +648,17 @@ dependencyInfoForFiles fs = do
   let deps = map (\i -> IM.lookup (getFilePathId i) (rawImports rawDepInfo)) _all_ids
       nodeKeys = IM.fromList $ catMaybes $ zipWith (\fi mms -> (getFilePathId fi,) . NodeKey_Module . msKey <$> mms) _all_ids mss
       mns = catMaybes $ zipWith go mss deps
+#if MIN_VERSION_ghc(9,13,0)
+      go (Just ms) (Just (Right (ModuleImports xs))) = Just $ ModuleNode this_dep_edges (ModuleNodeCompile ms)
+        where this_dep_ids = mapMaybe snd xs
+              this_dep_edges = map mkNormalEdge $ mapMaybe (\fi -> IM.lookup (getFilePathId fi) nodeKeys) this_dep_ids
+      go (Just ms) _ = Just $ ModuleNode [] (ModuleNodeCompile ms)
+#else
       go (Just ms) (Just (Right (ModuleImports xs))) = Just $ ModuleNode this_dep_keys ms
         where this_dep_ids = mapMaybe snd xs
               this_dep_keys = mapMaybe (\fi -> IM.lookup (getFilePathId fi) nodeKeys) this_dep_ids
       go (Just ms) _ = Just $ ModuleNode [] ms
+#endif
       go _ _ = Nothing
       mg = mkModuleGraph mns
   let shallowFingers = IntMap.fromList $ foldr' (\(i, m) acc -> case m of
@@ -773,8 +793,13 @@ ghcSessionDepsDefinition fullModSummary GhcSessionDepsConfig{..} hscEnvEq file =
                 !final_deps <- do
                   dep_mss <- map msrModSummary <$> uses_ GetModSummaryWithoutTimestamps deps
                   return $!! map (NodeKey_Module . msKey) dep_mss
+#if MIN_VERSION_ghc(9,13,0)
+                let module_graph_nodes =
+                      nubOrdOn mkNodeKey (ModuleNode (map mkNormalEdge final_deps) (ModuleNodeCompile ms) : concatMap mgModSummaries' mgs)
+#else
                 let module_graph_nodes =
                       nubOrdOn mkNodeKey (ModuleNode final_deps ms : concatMap mgModSummaries' mgs)
+#endif
                 liftIO $ evaluate $ liftRnf rwhnf module_graph_nodes
                 return $ mkModuleGraph module_graph_nodes
             session' <- liftIO $ mergeEnvs env mg de ms inLoadOrder depSessions
diff --git a/src/Development/IDE/Core/Shake.hs b/src/Development/IDE/Core/Shake.hs
index 2fbaa892fa..c5a0a49134 100644
--- a/src/Development/IDE/Core/Shake.hs
+++ b/src/Development/IDE/Core/Shake.hs
@@ -133,10 +133,16 @@ import qualified Language.LSP.Server                    as LSP
 
 import           Development.IDE.Core.Tracing
 import           Development.IDE.Core.WorkerThread
+#if MIN_VERSION_ghc(9,13,0)
+import           Development.IDE.GHC.Compat             (NameCache,
+                                                         NameCacheUpdater,
+                                                         newNameCache)
+#else
 import           Development.IDE.GHC.Compat             (NameCache,
                                                          NameCacheUpdater,
                                                          initNameCache,
                                                          knownKeyNames)
+#endif
 import           Development.IDE.GHC.Orphans            ()
 import           Development.IDE.Graph                  hiding (ShakeValue,
                                                          action)
@@ -666,7 +672,11 @@ shakeOpen recorder lspEnv defaultConfig idePlugins debouncer
         restartQueue = tRestartQueue threadQueue
         loaderQueue = tLoaderQueue threadQueue
 
+#if MIN_VERSION_ghc(9,13,0)
+    ideNc <- newNameCache
+#else
     ideNc <- initNameCache 'r' knownKeyNames
+#endif
     shakeExtras <- do
         globals <- newTVarIO HMap.empty
         state <- STM.newIO
diff --git a/src/Development/IDE/GHC/Compat.hs b/src/Development/IDE/GHC/Compat.hs
index befd22c8de..c8f6282338 100644
--- a/src/Development/IDE/GHC/Compat.hs
+++ b/src/Development/IDE/GHC/Compat.hs
@@ -66,6 +66,7 @@ module Development.IDE.GHC.Compat(
     simplifyExpr,
     tidyExpr,
     emptyTidyEnv,
+    tidyOpenType,
     corePrepExpr,
     corePrepPgm,
     lintInteractiveExpr,
@@ -73,6 +74,7 @@ module Development.IDE.GHC.Compat(
     HomePackageTable,
     lookupHpt,
     loadModulesHome,
+    hugElts,
     bcoFreeNames,
     ModIfaceAnnotation,
     pattern Annotation,
@@ -87,7 +89,9 @@ module Development.IDE.GHC.Compat(
     emptyInScopeSet,
     Unfolding(..),
     noUnfolding,
+#if !MIN_VERSION_ghc(9,13,0)
     loadExpr,
+#endif
     byteCodeGen,
     bc_bcos,
     loadDecls,
@@ -135,6 +139,7 @@ import           Prelude                                 hiding (mod)
 
 import qualified GHC.Core.Opt.Pipeline                   as GHC
 import           GHC.Core.Tidy                           (tidyExpr)
+import           GHC.Core.TyCo.Tidy                      (tidyOpenType)
 import           GHC.CoreToStg.Prep                      (corePrepPgm)
 import qualified GHC.CoreToStg.Prep                      as GHC
 import           GHC.Driver.Hooks                        (hscCompileCoreExprHook)
@@ -173,7 +178,11 @@ import           GHC.Driver.Config.CoreToStg.Prep        (initCorePrepConfig)
 import           GHC.Driver.Config.Stg.Pipeline
 import           GHC.Driver.Env                          as Env
 import           GHC.Iface.Env
-import           GHC.Linker.Loader                       (loadDecls, loadExpr)
+import           GHC.Linker.Loader                       (loadDecls
+#if !MIN_VERSION_ghc(9,13,0)
+                                                         , loadExpr
+#endif
+                                                         )
 import           GHC.Runtime.Context                     (icInteractiveModule)
 import           GHC.Stg.Pipeline
 import           GHC.Stg.Syntax
@@ -181,14 +190,23 @@ import           GHC.StgToByteCode
 import           GHC.Types.CostCentre
 import           GHC.Types.IPE
 import           GHC.Types.SrcLoc                        (combineRealSrcSpans)
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Unit.Home.PackageTable              (HomePackageTable,
+                                                          lookupHpt)
+#else
 import           GHC.Unit.Home.ModInfo                   (HomePackageTable,
                                                           lookupHpt)
+#endif
 import           GHC.Unit.Module.Deps                    (Dependencies (dep_direct_mods),
                                                           Usage (..))
 import           GHC.Unit.Module.ModIface
 
 -- See Note [Guidelines For Using CPP In GHCIDE Import Statements]
 
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Unit.Home.Graph                     (addHomeModInfoToHug, unitEnv_assocs)
+#endif
+
 #if MIN_VERSION_ghc(9,7,0)
 import           GHC.Tc.Zonk.TcType                      (tcInitTidyEnv)
 #endif
@@ -265,7 +283,11 @@ reLocA = reLoc
 #endif
 
 getDependentMods :: ModIface -> [ModuleName]
+#if MIN_VERSION_ghc(9,13,0)
+getDependentMods = map (gwib_mod . (\(_,_,x) -> x)) . S.toList . dep_direct_mods . mi_deps
+#else
 getDependentMods = map (gwib_mod . snd) . S.toList . dep_direct_mods . mi_deps
+#endif
 
 simplifyExpr :: DynFlags -> HscEnv -> CoreExpr -> IO CoreExpr
 simplifyExpr _ env = GHC.simplifyExpr (Development.IDE.GHC.Compat.Env.hsc_logger env) (ue_eps (Development.IDE.GHC.Compat.Env.hsc_unit_env env)) (initSimplifyExprOpts (hsc_dflags env) (hsc_IC env))
@@ -360,7 +382,11 @@ nameListFromAvails as =
 
 
 getModuleHash :: ModIface -> Fingerprint
+#if MIN_VERSION_ghc(9,13,0)
+getModuleHash = mi_mod_hash
+#else
 getModuleHash = mi_mod_hash . mi_final_exts
+#endif
 
 
 disableWarningsAsErrors :: DynFlags -> DynFlags
@@ -411,13 +437,16 @@ data GhcVersion
   | GHC98
   | GHC910
   | GHC912
+  | GHC914
   deriving (Eq, Ord, Show, Enum)
 
 ghcVersionStr :: String
 ghcVersionStr = VERSION_ghc
 
 ghcVersion :: GhcVersion
-#if MIN_VERSION_GLASGOW_HASKELL(9,12,0,0)
+#if MIN_VERSION_GLASGOW_HASKELL(9,14,0,0)
+ghcVersion = GHC914
+#elif MIN_VERSION_GLASGOW_HASKELL(9,12,0,0)
 ghcVersion = GHC912
 #elif MIN_VERSION_GLASGOW_HASKELL(9,10,0,0)
 ghcVersion = GHC910
@@ -455,9 +484,22 @@ mkAstNode n = Node (SourcedNodeInfo $ Map.singleton GeneratedInfo n)
 loadModulesHome
     :: [HomeModInfo]
     -> HscEnv
+#if MIN_VERSION_ghc(9,13,0)
+    -> IO HscEnv
+loadModulesHome mod_infos e = do
+  let hug = hsc_HUG (e { hsc_type_env_vars = emptyKnotVars })
+  mapM_ (`addHomeModInfoToHug` hug) mod_infos
+  pure (e { hsc_type_env_vars = emptyKnotVars })
+#else
     -> HscEnv
 loadModulesHome mod_infos e =
   hscUpdateHUG (\hug -> foldl' (flip addHomeModInfoToHug) hug mod_infos) (e { hsc_type_env_vars = emptyKnotVars })
+#endif
+
+#if MIN_VERSION_ghc(9,13,0)
+hugElts :: HomeUnitGraph -> [(UnitId, HomeUnitEnv)]
+hugElts = unitEnv_assocs
+#endif
 
 recDotDot :: HsRecFields (GhcPass p) arg -> Maybe Int
 recDotDot x =
diff --git a/src/Development/IDE/GHC/Compat/Core.hs b/src/Development/IDE/GHC/Compat/Core.hs
index 42f654b609..93c860ac7b 100644
--- a/src/Development/IDE/GHC/Compat/Core.hs
+++ b/src/Development/IDE/GHC/Compat/Core.hs
@@ -72,7 +72,9 @@ module Development.IDE.GHC.Compat.Core (
 #if MIN_VERSION_ghc(9,11,0)
     pattern ModIface,
     set_mi_top_env,
+#if !MIN_VERSION_ghc(9,13,0)
     set_mi_usages,
+#endif
 #endif
     HscSource(..),
     WhereFrom(..),
@@ -522,6 +524,9 @@ import           GHC.Unit.Finder             hiding (mkHomeModLocation)
 import qualified GHC.Unit.Finder             as GHC
 import           GHC.Unit.Finder.Types
 import           GHC.Unit.Home.ModInfo
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Unit.Home.PackageTable  (addToHpt, addListToHpt)
+#endif
 import           GHC.Unit.Module.Graph
 import           GHC.Unit.Module.Imported
 import           GHC.Unit.Module.ModDetails
@@ -534,7 +539,9 @@ import           GHC.Unit.Module.ModIface    (IfaceExport, ModIface,
 #if MIN_VERSION_ghc(9,11,0)
                                              , pattern ModIface
                                              , set_mi_top_env
+#if !MIN_VERSION_ghc(9,13,0)
                                              , set_mi_usages
+#endif
 #endif
                                              )
 import           GHC.Unit.Module.ModSummary  (ModSummary (..))
@@ -550,6 +557,10 @@ import           Language.Haskell.Syntax     hiding (FunDep)
 import System.OsPath
 #endif
 
+#if MIN_VERSION_ghc(9,13,0)
+import qualified System.FilePath as FP
+#endif
+
 #if !MIN_VERSION_ghc(9,7,0)
 import           GHC.Types.Avail             (greNamePrintableName)
 #endif
@@ -559,7 +570,17 @@ import           GHC.Hs                      (SrcSpanAnn')
 #endif
 
 mkHomeModLocation :: DynFlags -> ModuleName -> FilePath -> IO Module.ModLocation
-#if MIN_VERSION_ghc(9,11,0)
+#if MIN_VERSION_ghc(9,13,0)
+mkHomeModLocation df mn f =
+  let (basename, ext) = FP.splitExtension f
+      osBasename = unsafeEncodeUtf basename
+      osExt = unsafeEncodeUtf ext
+      hscSrc = case ext of
+        ".hs-boot" -> HsBootFile
+        ".hsig" -> HsigFile
+        _ -> HsSrcFile
+  in pure $ GHC.mkHomeModLocation (GHC.initFinderOpts df) mn osBasename osExt hscSrc
+#elif MIN_VERSION_ghc(9,11,0)
 mkHomeModLocation df mn f =
   let osf = unsafeEncodeUtf f
   in pure $ GHC.mkHomeModLocation (GHC.initFinderOpts df) mn osf
diff --git a/src/Development/IDE/GHC/Compat/Env.hs b/src/Development/IDE/GHC/Compat/Env.hs
index cbccc1a3de..7a458f08ef 100644
--- a/src/Development/IDE/GHC/Compat/Env.hs
+++ b/src/Development/IDE/GHC/Compat/Env.hs
@@ -3,9 +3,10 @@
 -- | Compat module for the main Driver types, such as 'HscEnv',
 -- 'UnitEnv' and some DynFlags compat functions.
 module Development.IDE.GHC.Compat.Env (
-    Env.HscEnv(hsc_FC, hsc_NC, hsc_IC, hsc_mod_graph
+    Env.HscEnv(hsc_FC, hsc_NC, hsc_IC
               , hsc_type_env_vars
               ),
+    Env.hsc_mod_graph,
     Env.hsc_HPT,
     InteractiveContext(..),
     setInteractivePrintName,
diff --git a/src/Development/IDE/GHC/Compat/Units.hs b/src/Development/IDE/GHC/Compat/Units.hs
index f7f634e448..752e32d812 100644
--- a/src/Development/IDE/GHC/Compat/Units.hs
+++ b/src/Development/IDE/GHC/Compat/Units.hs
@@ -75,26 +75,40 @@ import           GHC.Unit.State                        (LookupResult, UnitInfo,
 import qualified GHC.Unit.State                        as State
 import           GHC.Unit.Types
 
+#if MIN_VERSION_ghc(9,13,0)
+import qualified Data.Set                              as Set
+import           GHC.Unit.Home.Graph
+import           GHC.Unit.Home.PackageTable            (emptyHomePackageTable)
+import           GHC.Unit.Module.Graph                 (emptyMG)
+#endif
+
 
 type PreloadUnitClosure = UniqSet UnitId
 
 unitState :: HscEnv -> UnitState
 unitState = ue_units . hsc_unit_env
 
-createUnitEnvFromFlags :: NE.NonEmpty DynFlags -> HomeUnitGraph
-createUnitEnvFromFlags unitDflags =
-  let
-    newInternalUnitEnv dflags = mkHomeUnitEnv dflags emptyHomePackageTable Nothing
-    unitEnvList = NE.map (\dflags -> (homeUnitId_ dflags, newInternalUnitEnv dflags)) unitDflags
-  in
-    unitEnv_new (Map.fromList (NE.toList unitEnvList))
+createUnitEnvFromFlags :: NE.NonEmpty DynFlags -> IO HomeUnitGraph
+createUnitEnvFromFlags unitDflags = do
+#if MIN_VERSION_ghc(9,13,0)
+  let mkEntry dflags = do
+        hpt <- emptyHomePackageTable
+        let us = State.emptyUnitState -- placeholder UnitState
+        pure (homeUnitId_ dflags, mkHomeUnitEnv us Nothing dflags hpt Nothing)
+  unitEnvList <- mapM mkEntry (NE.toList unitDflags)
+  pure $ unitEnv_new (Map.fromList unitEnvList)
+#else
+  let newInternalUnitEnv dflags = mkHomeUnitEnv dflags emptyHomePackageTable Nothing
+      unitEnvList = NE.map (\dflags -> (homeUnitId_ dflags, newInternalUnitEnv dflags)) unitDflags
+  pure $ unitEnv_new (Map.fromList (NE.toList unitEnvList))
+#endif
 
 initUnits :: [DynFlags] -> HscEnv -> IO HscEnv
 initUnits unitDflags env = do
   let dflags0         = hsc_dflags env
   -- additionally, set checked dflags so we don't lose fixes
-  let initial_home_graph = createUnitEnvFromFlags (dflags0 NE.:| unitDflags)
-      home_units = unitEnv_keys initial_home_graph
+  initial_home_graph <- createUnitEnvFromFlags (dflags0 NE.:| unitDflags)
+  let home_units = unitEnv_keys initial_home_graph
   home_unit_graph <- forM initial_home_graph $ \homeUnitEnv -> do
     let cached_unit_dbs = homeUnitEnv_unit_dbs homeUnitEnv
         dflags = homeUnitEnv_dflags homeUnitEnv
@@ -118,6 +132,9 @@ initUnits unitDflags env = do
         , ue_home_unit_graph = home_unit_graph
         , ue_current_unit    = homeUnitId_ dflags0
         , ue_eps             = ue_eps (hsc_unit_env env)
+#if MIN_VERSION_ghc(9,13,0)
+        , ue_module_graph    = emptyMG
+#endif
         }
   pure $ hscSetFlags dflags1 $ hscSetUnitEnv unit_env env
 
diff --git a/src/Development/IDE/GHC/Orphans.hs b/src/Development/IDE/GHC/Orphans.hs
index 068ca6a78a..b3b59f5c1a 100644
--- a/src/Development/IDE/GHC/Orphans.hs
+++ b/src/Development/IDE/GHC/Orphans.hs
@@ -26,6 +26,9 @@ import           GHC.Iface.Ext.Types
 import           GHC.Parser.Annotation
 import           GHC.Types.PkgQual
 import           GHC.Types.SrcLoc
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Types.Basic                   (ImportLevel)
+#endif
 
 -- See Note [Guidelines For Using CPP In GHCIDE Import Statements]
 
@@ -44,7 +47,9 @@ instance Show CgGuts where show = unpack . printOutputable . cg_module
 instance NFData CgGuts where rnf = rwhnf
 instance Show ModDetails where show = const "<moddetails>"
 instance NFData ModDetails where rnf = rwhnf
+#if !MIN_VERSION_ghc(9,13,0)
 instance NFData SafeHaskellMode where rnf = rwhnf
+#endif
 instance Show Linkable where show = unpack . printOutputable
 #if MIN_VERSION_ghc(9,11,0)
 instance NFData Linkable where rnf (Linkable a b c) = rnf a `seq` rnf b `seq` rnf c
@@ -136,8 +141,10 @@ instance Hashable ModuleName where
 instance NFData a => NFData (IdentifierDetails a) where
     rnf (IdentifierDetails a b) = rnf a `seq` rnf (length b)
 
+#if !MIN_VERSION_ghc(9,13,0)
 instance NFData RealSrcSpan where
     rnf = rwhnf
+#endif
 
 srcSpanFileTag, srcSpanStartLineTag, srcSpanStartColTag,
     srcSpanEndLineTag, srcSpanEndColTag :: String
@@ -209,8 +216,10 @@ instance NFData PkgQual where
   rnf (ThisPkg uid)  = rnf uid
   rnf (OtherPkg uid) = rnf uid
 
+#if !MIN_VERSION_ghc(9,13,0)
 instance NFData UnitId where
   rnf = rwhnf
+#endif
 
 instance NFData NodeKey where
   rnf = rwhnf
@@ -235,3 +244,8 @@ instance NFData Extension where
 
 instance NFData (UniqFM Name [Name]) where
   rnf (ufmToIntMap -> m) = rnf m
+
+#if MIN_VERSION_ghc(9,13,0)
+instance NFData ImportLevel where
+  rnf = rwhnf
+#endif
diff --git a/src/Development/IDE/LSP/Outline.hs b/src/Development/IDE/LSP/Outline.hs
index af2a0f1c97..cec445601c 100644
--- a/src/Development/IDE/LSP/Outline.hs
+++ b/src/Development/IDE/LSP/Outline.hs
@@ -256,8 +256,14 @@ hsConDeclsBinders cons
 #endif
     get_flds_gadt _                   = []
 
+#if MIN_VERSION_ghc(9,13,0)
+    get_flds :: Located [LHsConDeclRecField GhcPs]
+             -> [LFieldOcc GhcPs]
+    get_flds flds = concatMap (cdrf_names . unLoc) (unLoc flds)
+#else
     get_flds :: Located [LConDeclField GhcPs]
              -> [LFieldOcc GhcPs]
     get_flds flds = concatMap (cd_fld_names . unLoc) (unLoc flds)
+#endif
 
 
diff --git a/src/Development/IDE/Plugin/Completions/Logic.hs b/src/Development/IDE/Plugin/Completions/Logic.hs
index 018d08cb06..55ea002fc6 100644
--- a/src/Development/IDE/Plugin/Completions/Logic.hs
+++ b/src/Development/IDE/Plugin/Completions/Logic.hs
@@ -490,10 +490,17 @@ findRecordCompl uri mn DataDecl {tcdLName, tcdDataDefn} = result
             --
             -- is encoded as @[[arg1, arg2], [arg3], [arg4]]@
             -- Hence, we must concat nested arguments into one to get all the fields.
+#if MIN_VERSION_ghc(9,13,0)
+        extract HsConDeclRecField{..}
+            = map (foLabel . unLoc) cdrf_names
+        -- XConDeclRecField
+        extract _ = []
+#else
         extract ConDeclField{..}
             = map (foLabel . unLoc) cd_fld_names
         -- XConDeclField
         extract _ = []
+#endif
 findRecordCompl _ _ _ = []
 
 toggleSnippets :: ClientCapabilities -> CompletionsConfig -> CompletionItem -> CompletionItem
diff --git a/src/Development/IDE/Plugin/TypeLenses.hs b/src/Development/IDE/Plugin/TypeLenses.hs
index c596d1fb82..63a0a9a7fa 100644
--- a/src/Development/IDE/Plugin/TypeLenses.hs
+++ b/src/Development/IDE/Plugin/TypeLenses.hs
@@ -57,6 +57,7 @@ import           Development.IDE.GHC.Util             (printName)
 import           Development.IDE.Graph.Classes
 import           Development.IDE.Types.Location       (Position (Position, _line),
                                                        Range (Range, _end, _start))
+import           GHC.Core.TyCo.Tidy                   (tidyOpenType)
 import           GHC.Generics                         (Generic)
 import           Ide.Logger                           (Pretty (pretty),
                                                        Recorder, WithPriority,
diff --git a/src/Development/IDE/Types/HscEnvEq.hs b/src/Development/IDE/Types/HscEnvEq.hs
index 1c2ed1732f..293326c372 100644
--- a/src/Development/IDE/Types/HscEnvEq.hs
+++ b/src/Development/IDE/Types/HscEnvEq.hs
@@ -61,11 +61,19 @@ newHscEnvEq hscEnv' = do
     let hscEnv = hscEnv'
                { hsc_FC = FinderCache
                         { flushFinderCaches = \_ -> error "GHC should never call flushFinderCaches outside the driver"
+#if MIN_VERSION_ghc(9,13,0)
+                        , addToFinderCache  = \im val -> do
+#else
                         , addToFinderCache  = \(GWIB im _) val -> do
+#endif
                             if moduleUnit im `elem` hsc_all_home_unit_ids hscEnv'
                             then error "tried to add home module to FC"
                             else atomicModifyIORef' mod_cache $ \c -> (extendInstalledModuleEnv c im val, ())
+#if MIN_VERSION_ghc(9,13,0)
+                        , lookupFinderCache = \im -> do
+#else
                         , lookupFinderCache = \(GWIB im _) -> do
+#endif
                             if moduleUnit im `elem` hsc_all_home_unit_ids hscEnv'
                             then error ("tried to lookup home module from FC" ++ showSDocUnsafe (ppr (im, hsc_all_home_unit_ids hscEnv')))
                             else lookupInstalledModuleEnv <$> readIORef mod_cache <*> pure im
