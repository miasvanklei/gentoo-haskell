diff --color -ur a/src/Development/IDE/Core/Actions.hs b/src/Development/IDE/Core/Actions.hs
--- a/src/Development/IDE/Core/Actions.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Core/Actions.hs	2025-02-03 13:57:15.852468052 +0100
@@ -132,7 +132,7 @@
 
 highlightAtPoint :: NormalizedFilePath -> Position -> IdeAction (Maybe [DocumentHighlight])
 highlightAtPoint file pos = runMaybeT $ do
-    (HAR _ hf rf _ _,mapping) <- useWithStaleFastMT GetHieAst file
+    (HAR _ hf _ rf _ _,mapping) <- useWithStaleFastMT GetHieAst file
     !pos' <- MaybeT (return $ fromCurrentPosition mapping pos)
     let toCurrentHighlight (DocumentHighlight range t) = flip DocumentHighlight t <$> toCurrentRange mapping range
     mapMaybe toCurrentHighlight <$>AtPoint.documentHighlight hf rf pos'
diff --color -ur a/src/Development/IDE/Core/Compile.hs b/src/Development/IDE/Core/Compile.hs
--- a/src/Development/IDE/Core/Compile.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Core/Compile.hs	2025-02-03 13:57:15.856468010 +0100
@@ -62,11 +62,12 @@
 import           Data.IntMap                            (IntMap)
 import           Data.IORef
 import           Data.List.Extra
+import qualified Data.List.NonEmpty                     as NE
 import qualified Data.Map.Strict                        as Map
 import           Data.Maybe
 import           Data.Proxy                             (Proxy (Proxy))
 import qualified Data.Text                              as T
-import           Data.Time                              (UTCTime (..))
+import           Data.Time                              (UTCTime (..), getCurrentTime)
 import           Data.Tuple.Extra                       (dupe)
 import           Debug.Trace
 import           Development.IDE.Core.FileStore         (resetInterfaceStore)
@@ -130,6 +131,10 @@
 import           Development.IDE.Core.FileStore         (shareFilePath)
 #endif
 
+import Development.IDE.Import.DependencyInformation
+import GHC.Driver.Env ( hsc_all_home_unit_ids )
+import Development.IDE.Import.FindImports
+
 --Simple constants to make sure the source is consistently named
 sourceTypecheck :: T.Text
 sourceTypecheck = "typecheck"
@@ -161,9 +166,10 @@
             T.pack $ "unknown package: " ++ show pkg]
         Just pkgInfo -> return $ Right $ unitDepends pkgInfo
 
-newtype TypecheckHelpers
+data TypecheckHelpers
   = TypecheckHelpers
   { getLinkables       :: [NormalizedFilePath] -> IO [LinkableResult] -- ^ hls-graph action to get linkables for files
+  , getModuleGraph :: IO DependencyInformation
   }
 
 typecheckModule :: IdeDefer
@@ -260,6 +266,9 @@
                        (icInteractiveModule ictxt)
                        stg_expr
                        [] Nothing
+#if MIN_VERSION_ghc(9,11,0)
+                       [] -- spt_entries
+#endif
 
             -- Exclude wired-in names because we may not have read
             -- their interface files, so getLinkDeps will fail
@@ -283,19 +292,30 @@
                  mods_transitive_list =
                                          mapMaybe nodeKeyToInstalledModule $ Set.toList mods_transitive
 
-           ; moduleLocs <- readIORef (fcModuleCache $ hsc_FC hsc_env)
-           ; lbs <- getLinkables [toNormalizedFilePath' file
+           ; moduleLocs <- getModuleGraph
+           ; lbs <- getLinkables [file
                                  | installedMod <- mods_transitive_list
+#if MIN_VERSION_ghc(9,11,0)
+                                 , let file = fromJust $ lookupModuleFile (installedMod { moduleUnit = RealUnit (Definite $ moduleUnit installedMod) }) moduleLocs
+#else
+
                                  , let ifr = fromJust $ lookupInstalledModuleEnv moduleLocs installedMod
-                                       file = case ifr of
+                                       file = toNormalizedFilePath' $ case ifr of
                                          InstalledFound loc _ ->
                                            fromJust $ ml_hs_file loc
                                          _ -> panic "hscCompileCoreExprHook: module not found"
+#endif
                                  ]
            ; let hsc_env' = loadModulesHome (map linkableHomeMod lbs) hsc_env
 
              {- load it -}
+#if MIN_VERSION_ghc(9,11,0)
+           ; bco_time <- getCurrentTime
+           ; (fv_hvs, lbss, pkgs) <- loadDecls (hscInterp hsc_env') hsc_env' srcspan $
+                Linkable bco_time (icInteractiveModule ictxt) $ NE.singleton $ BCOs bcos
+#else
            ; (fv_hvs, lbss, pkgs) <- loadDecls (hscInterp hsc_env') hsc_env' srcspan bcos
+#endif
            ; let hval = (expectJust "hscCompileCoreExpr'" $ lookup (idName binding_id) fv_hvs, lbss, pkgs)
 
            ; modifyIORef' var (flip extendModuleEnvList [(mi_module $ hm_iface hm, linkableHash lb) | lb <- lbs, let hm = linkableHomeMod lb])
@@ -419,7 +439,14 @@
   details <- makeSimpleDetails hsc_env_tmp tcGblEnv
   sf <- finalSafeMode (ms_hspp_opts ms) tcGblEnv
   iface' <- mkIfaceTc hsc_env_tmp sf details ms Nothing tcGblEnv
-  let iface = iface' { mi_globals = Nothing, mi_usages = filterUsages (mi_usages iface') } -- See Note [Clearing mi_globals after generating an iface]
+  -- See Note [Clearing mi_globals after generating an iface]
+  let iface = iface'
+#if MIN_VERSION_ghc(9,11,0)
+                & set_mi_top_env Nothing
+                & set_mi_usages (filterUsages (mi_usages iface'))
+#else
+                { mi_globals = Nothing, mi_usages = filterUsages (mi_usages iface') }
+#endif
   pure $! mkHiFileResult ms iface details (tmrRuntimeModules tcm) Nothing
 
 mkHiFileResultCompile
@@ -445,13 +472,26 @@
 #endif
                                               details
                                               ms
+#if MIN_VERSION_ghc(9,11,0)
+                                              (tcg_import_decls (tmrTypechecked tcm))
+#endif
                                               simplified_guts
 
   final_iface' <- mkFullIface session partial_iface Nothing
 #if MIN_VERSION_ghc(9,4,2)
                     Nothing
 #endif
-  let final_iface = final_iface' {mi_globals = Nothing, mi_usages = filterUsages (mi_usages final_iface')} -- See Note [Clearing mi_globals after generating an iface]
+#if MIN_VERSION_ghc(9,11,0)
+                    NoStubs []
+#endif
+  -- See Note [Clearing mi_globals after generating an iface]
+  let final_iface = final_iface'
+#if MIN_VERSION_ghc(9,11,0)
+                      & set_mi_top_env Nothing
+                      & set_mi_usages (filterUsages (mi_usages final_iface'))
+#else
+                      {mi_globals = Nothing, mi_usages = filterUsages (mi_usages final_iface')}
+#endif
 
   -- Write the core file now
   core_file <- do
@@ -459,7 +499,7 @@
             core_file = codeGutsToCoreFile iface_hash guts
             iface_hash = getModuleHash final_iface
         core_hash1 <- atomicFileWrite se core_fp $ \fp ->
-          writeBinCoreFile fp core_file
+          writeBinCoreFile (hsc_dflags session) fp core_file
         -- We want to drop references to guts and read in a serialized, compact version
         -- of the core file from disk (as it is deserialised lazily)
         -- This is because we don't want to keep the guts in memory for every file in
@@ -609,11 +649,13 @@
                       case obj of
                         Nothing -> throwGhcExceptionIO $ Panic "compileFile didn't generate object code"
                         Just x -> pure x
-              let unlinked = DotO dot_o_fp
               -- Need time to be the modification time for recompilation checking
               t <- liftIO $ getModificationTime dot_o_fp
-              let linkable = LM t mod [unlinked]
-
+#if MIN_VERSION_ghc(9,11,0)
+              let linkable = Linkable t mod (pure $ DotO dot_o_fp ModuleObject)
+#else
+              let linkable = LM t mod [DotO dot_o_fp]
+#endif
               pure (map snd warnings, linkable)
 
 newtype CoreFileTime = CoreFileTime UTCTime
@@ -622,15 +664,22 @@
 generateByteCode (CoreFileTime time) hscEnv summary guts = do
     fmap (either (, Nothing) (second Just)) $
           catchSrcErrors (hsc_dflags hscEnv) "bytecode" $ do
+#if MIN_VERSION_ghc(9,11,0)
+              (warnings, (_, bytecode)) <-
+#else
               (warnings, (_, bytecode, sptEntries)) <-
+#endif
                 withWarnings "bytecode" $ \_tweak -> do
                       let session = _tweak (hscSetFlags (ms_hspp_opts summary) hscEnv)
                           -- TODO: maybe settings ms_hspp_opts is unnecessary?
                           summary' = summary { ms_hspp_opts = hsc_dflags session }
                       hscInteractive session (mkCgInteractiveGuts guts)
                                 (ms_location summary')
-              let unlinked = BCOs bytecode sptEntries
-              let linkable = LM time (ms_mod summary) [unlinked]
+#if MIN_VERSION_ghc(9,11,0)
+              let linkable = Linkable time (ms_mod summary) (pure $ BCOs bytecode)
+#else
+              let linkable = LM time (ms_mod summary) [BCOs bytecode sptEntries]
+#endif
               pure (map snd warnings, linkable)
 
 demoteTypeErrorsToWarnings :: ParsedModule -> ParsedModule
@@ -730,21 +779,40 @@
   (write tempFilePath >>= \x -> renameFile tempFilePath targetPath >> atomically (resetInterfaceStore se (toNormalizedFilePath' targetPath)) >> pure x)
     `onException` cleanUp
 
+#if MIN_VERSION_ghc(9,11,0)
+generateHieAsts :: HscEnv -> TcModuleResult -> IO ([FileDiagnostic], Maybe (HieASTs Type, NameEntityInfo))
+#else
 generateHieAsts :: HscEnv -> TcModuleResult -> IO ([FileDiagnostic], Maybe (HieASTs Type))
+#endif
 generateHieAsts hscEnv tcm =
   handleGenerationErrors' dflags "extended interface generation" $ runHsc hscEnv $ do
     -- These varBinds use unitDataConId but it could be anything as the id name is not used
     -- during the hie file generation process. It's a workaround for the fact that the hie modules
     -- don't export an interface which allows for additional information to be added to hie files.
-    let fake_splice_binds = Util.listToBag (map (mkVarBind unitDataConId) (spliceExpressions $ tmrTopLevelSplices tcm))
+    let fake_splice_binds =
+#if !MIN_VERSION_ghc(9,11,0)
+                            Util.listToBag $
+#endif
+                            map (mkVarBind unitDataConId) (spliceExpressions $ tmrTopLevelSplices tcm)
         real_binds = tcg_binds $ tmrTypechecked tcm
+        all_binds =
+#if MIN_VERSION_ghc(9,11,0)
+          fake_splice_binds ++ real_binds
+#else
+          fake_splice_binds `Util.unionBags` real_binds
+#endif
         ts = tmrTypechecked tcm :: TcGblEnv
         top_ev_binds = tcg_ev_binds ts :: Util.Bag EvBind
         insts = tcg_insts ts :: [ClsInst]
         tcs = tcg_tcs ts :: [TyCon]
+        hie_asts = GHC.enrichHie all_binds (tmrRenamed tcm) top_ev_binds insts tcs
 
     pure $ Just $
-        GHC.enrichHie (fake_splice_binds `Util.unionBags` real_binds) (tmrRenamed tcm) top_ev_binds insts tcs
+#if MIN_VERSION_ghc(9,11,0)
+      hie_asts (tcg_type_env ts)
+#elif MIN_VERSION_ghc(9,3,0)
+      hie_asts
+#endif
   where
     dflags = hsc_dflags hscEnv
 
@@ -832,11 +900,11 @@
             toJSON $ fromNormalizedFilePath srcPath
       whenJust mdone $ \_ -> progressUpdate indexProgressReporting ProgressCompleted
 
-writeAndIndexHieFile :: HscEnv -> ShakeExtras -> ModSummary -> NormalizedFilePath -> [GHC.AvailInfo] -> HieASTs Type -> BS.ByteString -> IO [FileDiagnostic]
-writeAndIndexHieFile hscEnv se mod_summary srcPath exports ast source =
+writeAndIndexHieFile :: HscEnv -> ShakeExtras -> ModSummary -> NormalizedFilePath -> [GHC.AvailInfo] -> HieASTs Type -> NameEntityInfo -> BS.ByteString -> IO [FileDiagnostic]
+writeAndIndexHieFile hscEnv se mod_summary srcPath exports ast entityInfos source =
   handleGenerationErrors dflags "extended interface write/compression" $ do
     hf <- runHsc hscEnv $
-      GHC.mkHieFile' mod_summary exports ast source
+      GHC.mkHieFile' mod_summary exports ast entityInfos source
     atomicFileWrite se targetPath $ flip GHC.writeHieFile hf
     hash <- Util.getFileHash targetPath
     indexHieFile se mod_summary srcPath hash hf
@@ -877,8 +945,52 @@
 -- Add the current ModSummary to the graph, along with the
 -- HomeModInfo's of all direct dependencies (by induction hypothesis all
 -- transitive dependencies will be contained in envs)
-mergeEnvs :: HscEnv -> ModuleGraph -> ModSummary -> [HomeModInfo] -> [HscEnv] -> IO HscEnv
-mergeEnvs env mg ms extraMods envs = do
+mergeEnvs :: HscEnv
+          -> ModuleGraph
+          -> DependencyInformation
+          -> ModSummary
+          -> [HomeModInfo]
+          -> [HscEnv]
+          -> IO HscEnv
+mergeEnvs env mg dep_info ms extraMods envs = do
+#if MIN_VERSION_ghc(9,11,0)
+    return $! loadModulesHome extraMods $
+      let newHug = foldl' mergeHUG (hsc_HUG env) (map hsc_HUG envs) in
+      (hscUpdateHUG (const newHug) env){
+          hsc_mod_graph = mg,
+          hsc_FC = (hsc_FC env)
+            { addToFinderCache = \gwib@(GWIB im _) val ->
+                  if moduleUnit im `elem` hsc_all_home_unit_ids env
+                  then pure ()
+                  else addToFinderCache (hsc_FC env) gwib val
+            , lookupFinderCache = \gwib@(GWIB im _) ->
+                  if moduleUnit im `elem` hsc_all_home_unit_ids env
+                  then case lookupModuleFile (im { moduleUnit = RealUnit (Definite $ moduleUnit im) }) dep_info of
+                         Nothing -> pure Nothing
+                         Just fs -> let ml = fromJust $ do
+                                              id <- lookupPathToId (depPathIdMap dep_info) fs
+                                              artifactModLocation (idToModLocation (depPathIdMap dep_info) id)
+                                    in pure $ Just $ InstalledFound ml im
+                  else lookupFinderCache (hsc_FC env) gwib
+                  {-
+            , lookupFileCache = \fp ->
+                case lookup fp dependentHashes of
+                  Just res -> return res
+                  Nothing -> lookupFileCache (hsc_FC env) fp
+                  -}
+            }
+      }
+
+    where
+        mergeHUG (UnitEnvGraph a) (UnitEnvGraph b) = UnitEnvGraph $ Map.unionWith mergeHUE a b
+        mergeHUE a b = a { homeUnitEnv_hpt = mergeUDFM (homeUnitEnv_hpt a) (homeUnitEnv_hpt b) }
+        mergeUDFM = plusUDFM_C combineModules
+
+        combineModules a b
+          | HsSrcFile <- mi_hsc_src (hm_iface a) = a
+          | otherwise = b
+
+#elif MIN_VERSION_ghc(9,3,0)
     let im  = Compat.installedModule (toUnitId $ moduleUnit $ ms_mod ms) (moduleName (ms_mod ms))
         ifr = InstalledFound (ms_location ms) im
         curFinderCache = Compat.extendInstalledModuleEnv Compat.emptyInstalledModuleEnv im ifr
@@ -912,6 +1024,7 @@
           fcModules' <- newIORef $! foldl' (plusInstalledModuleEnv combineModuleLocations) cur fcModules
           fcFiles' <- newIORef $! Map.unions fcFiles
           pure $ FinderCache fcModules' fcFiles'
+#endif
 
 
 withBootSuffix :: HscSource -> ModLocation -> ModLocation
@@ -1213,6 +1326,7 @@
   , old_value   :: Maybe (HiFileResult, FileVersion)
   , get_file_version :: NormalizedFilePath -> m (Maybe FileVersion)
   , get_linkable_hashes :: [NormalizedFilePath] -> m [BS.ByteString]
+  , get_module_graph :: m DependencyInformation
   , regenerate  :: Maybe LinkableType -> m ([FileDiagnostic], Maybe HiFileResult) -- ^ Action to regenerate an interface
   }
 
@@ -1295,7 +1409,7 @@
                    | not (mi_used_th iface) = emptyModuleEnv
                    | otherwise = parseRuntimeDeps (md_anns details)
              -- Peform the fine grained recompilation check for TH
-             maybe_recomp <- checkLinkableDependencies session get_linkable_hashes runtime_deps
+             maybe_recomp <- checkLinkableDependencies session get_linkable_hashes get_module_graph runtime_deps
              case maybe_recomp of
                Just msg -> do_regenerate msg
                Nothing
@@ -1332,8 +1446,12 @@
 -- the runtime dependencies of the module, to check if any of them are out of date
 -- Hopefully 'runtime_deps' will be empty if the module didn't actually use TH
 -- See Note [Recompilation avoidance in the presence of TH]
-checkLinkableDependencies :: MonadIO m => HscEnv -> ([NormalizedFilePath] -> m [BS.ByteString]) -> ModuleEnv BS.ByteString -> m (Maybe RecompileRequired)
-checkLinkableDependencies hsc_env get_linkable_hashes runtime_deps = do
+checkLinkableDependencies :: MonadIO m => HscEnv -> ([NormalizedFilePath] -> m [BS.ByteString]) -> m DependencyInformation -> ModuleEnv BS.ByteString -> m (Maybe RecompileRequired)
+checkLinkableDependencies hsc_env get_linkable_hashes get_module_graph runtime_deps = do
+#if MIN_VERSION_ghc(9,11,0)
+  graph <- get_module_graph
+  let go (mod, hash) = (,hash) <$> lookupModuleFile mod graph
+#else
   moduleLocs <- liftIO $ readIORef (fcModuleCache $ hsc_FC hsc_env)
   let go (mod, hash) = do
         ifr <- lookupInstalledModuleEnv moduleLocs $ Compat.installedModule (toUnitId $ moduleUnit mod) (moduleName mod)
@@ -1342,6 +1460,7 @@
             hs <- ml_hs_file loc
             pure (toNormalizedFilePath' hs,hash)
           _ -> Nothing
+#endif
       hs_files = mapM go (moduleEnvToList runtime_deps)
   case hs_files of
     Nothing -> error "invalid module graph"
@@ -1387,7 +1506,11 @@
       tyCons = typeEnvTyCons (md_types details)
 #if MIN_VERSION_ghc(9,5,0)
   -- In GHC 9.6, the implicit binds are tidied and part of core_binds
-  pure $ CgGuts this_mod tyCons core_binds [] NoStubs [] mempty (emptyHpcInfo False) Nothing []
+  pure $ CgGuts this_mod tyCons core_binds [] NoStubs [] mempty
+#if !MIN_VERSION_ghc(9,11,0)
+                (emptyHpcInfo False)
+#endif
+                Nothing []
 #else
   pure $ CgGuts this_mod tyCons (_implicit_binds ++ core_binds) [] NoStubs [] mempty (emptyHpcInfo False) Nothing []
 #endif
diff --color -ur a/src/Development/IDE/Core/RuleTypes.hs b/src/Development/IDE/Core/RuleTypes.hs
--- a/src/Development/IDE/Core/RuleTypes.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Core/RuleTypes.hs	2025-02-03 13:57:15.856468010 +0100
@@ -24,7 +24,7 @@
 import           Data.Time.Clock.POSIX
 import           Data.Typeable
 import           Development.IDE.GHC.Compat                   hiding
-                                                              (HieFileResult)
+                                                              (HieFileResult, assert)
 import           Development.IDE.GHC.Compat.Util
 import           Development.IDE.GHC.CoreFile
 import           Development.IDE.GHC.Util
@@ -206,6 +206,7 @@
   = forall a . (Typeable a) =>  HAR
   { hieModule :: Module
   , hieAst    :: !(HieASTs a)
+  , entity_infos :: NameEntityInfo
   , refMap    :: RefMap a
   -- ^ Lazy because its value only depends on the hieAst, which is bundled in this type
   -- Lazyness can't cause leaks here because the lifetime of `refMap` will be the same
@@ -225,7 +226,7 @@
     rnf HieFresh         = ()
 
 instance NFData HieAstResult where
-    rnf (HAR m hf _rm _tr kind) = rnf m `seq` rwhnf hf `seq` rnf kind
+    rnf (HAR m hf _ei _rm _tr kind) = rnf m `seq` rwhnf hf `seq` rnf kind
 
 instance Show HieAstResult where
     show = show . hieModule
@@ -279,6 +280,8 @@
 
 type instance RuleResult GetFileExists = Bool
 
+type instance RuleResult GetFileHash = Fingerprint
+
 type instance RuleResult AddWatchedFile = Bool
 
 
@@ -334,6 +337,12 @@
 instance NFData   GetFileExists
 instance Hashable GetFileExists
 
+data GetFileHash = GetFileHash
+    deriving (Eq, Show, Typeable, Generic)
+
+instance NFData   GetFileHash
+instance Hashable GetFileHash
+
 data FileOfInterestStatus
   = OnDisk
   | Modified { firstOpen :: !Bool -- ^ was this file just opened
diff --color -ur a/src/Development/IDE/Core/Rules.hs b/src/Development/IDE/Core/Rules.hs
--- a/src/Development/IDE/Core/Rules.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Core/Rules.hs	2025-02-03 14:22:50.332249907 +0100
@@ -521,7 +521,7 @@
     Just vf -> pure (virtualFileText vf, Just $ virtualFileVersion vf)
   let refmap = Compat.generateReferencesMap . Compat.getAsts . Compat.hie_asts $ res
       del = deltaFromDiff (T.decodeUtf8 $ Compat.hie_hs_src res) currentSource
-  pure (HAR (Compat.hie_module res) (Compat.hie_asts res) refmap mempty (HieFromDisk res),del,ver)
+  pure (HAR (Compat.hie_module res) (Compat.hie_asts res) mempty refmap mempty (HieFromDisk res),del,ver)
 
 getHieAstRuleDefinition :: NormalizedFilePath -> HscEnv -> TcModuleResult -> Action (IdeResult HieAstResult)
 getHieAstRuleDefinition f hsc tmr = do
@@ -535,16 +535,19 @@
         LSP.sendNotification (SMethod_CustomMethod (Proxy @"a/reference/ready")) $
           toJSON $ fromNormalizedFilePath f
       pure []
-    _ | Just asts <- masts -> do
+    _ | Just (asts, entityInfos) <- masts -> do
           source <- getSourceFileSource f
           let exports = tcg_exports $ tmrTypechecked tmr
               modSummary = tmrModSummary tmr
-          liftIO $ writeAndIndexHieFile hsc se modSummary f exports asts source
+          liftIO $ writeAndIndexHieFile hsc se modSummary f exports asts entityInfos source
     _ -> pure []
 
-  let refmap = Compat.generateReferencesMap . Compat.getAsts <$> masts
-      typemap = AtPoint.computeTypeReferences . Compat.getAsts <$> masts
-  pure (diags <> diagsWrite, HAR (ms_mod $ tmrModSummary tmr) <$> masts <*> refmap <*> typemap <*> pure HieFresh)
+  let har = do
+        (asts, entityInfos) <- masts
+        let refmap = Compat.generateReferencesMap $ Compat.getAsts asts
+            typemap = AtPoint.computeTypeReferences $ Compat.getAsts asts
+        pure $ HAR (ms_mod $ tmrModSummary tmr) asts entityInfos refmap typemap HieFresh
+  pure (diags <> diagsWrite, har)
 
 getImportMapRule :: Recorder (WithPriority Log) -> Rules ()
 getImportMapRule recorder = define (cmapWithPrio LogShake recorder) $ \GetImportMap f -> do
@@ -616,6 +619,13 @@
   fs <- knownTargets
   pure (LBS.toStrict $ B.encode $ hash fs, unhashed fs)
 
+getFileHashRule :: Recorder (WithPriority Log) -> Rules ()
+getFileHashRule recorder =
+    defineEarlyCutoff (cmapWithPrio LogShake recorder) $ Rule $ \GetFileHash file -> do
+        void $ use_ GetModificationTime file
+        fileHash <- liftIO $ Util.getFileHash (fromNormalizedFilePath file)
+        return (Just (fingerprintToBS fileHash), ([], Just fileHash))
+
 getModuleGraphRule :: Recorder (WithPriority Log) -> Rules ()
 getModuleGraphRule recorder = defineEarlyCutOffNoFile (cmapWithPrio LogShake recorder) $ \GetModuleGraph -> do
   fs <- toKnownFiles <$> useNoFile_ GetKnownTargets
@@ -652,6 +662,7 @@
   unlift <- askUnliftIO
   let dets = TypecheckHelpers
            { getLinkables = unliftIO unlift . uses_ GetLinkable
+           , getModuleGraph = unliftIO unlift $ useNoFile_ GetModuleGraph
            }
   addUsageDependencies $ liftIO $
     typecheckModule defer hsc dets pm
@@ -763,7 +774,8 @@
                       nubOrdOn mkNodeKey (ModuleNode final_deps ms : concatMap mgModSummaries' mgs)
                 liftIO $ evaluate $ liftRnf rwhnf module_graph_nodes
                 return $ mkModuleGraph module_graph_nodes
-            session' <- liftIO $ mergeEnvs hsc mg ms inLoadOrder depSessions
+            de <- useNoFile_ GetModuleGraph
+            session' <- liftIO $ mergeEnvs hsc mg de ms inLoadOrder depSessions
 
             -- Here we avoid a call to to `newHscEnvEqWithImportPaths`, which creates a new
             -- ExportsMap when it is called. We only need to create the ExportsMap once per
@@ -792,9 +804,11 @@
             , old_value = m_old
             , get_file_version = use GetModificationTime_{missingFileDiagnostics = False}
             , get_linkable_hashes = \fs -> map (snd . fromJust . hirCoreFp) <$> uses_ GetModIface fs
+            , get_module_graph = useNoFile_ GetModuleGraph
             , regenerate = regenerateHiFile session f ms
             }
-      r <- loadInterface (hscEnv session) ms linkableType recompInfo
+      hsc_env' <- setFileCacheHook (hscEnv session)
+      r <- loadInterface hsc_env' ms linkableType recompInfo
       case r of
         (diags, Nothing) -> return (Nothing, (diags, Nothing))
         (diags, Just x) -> do
@@ -893,8 +907,9 @@
 generateCore :: RunSimplifier -> NormalizedFilePath -> Action (IdeResult ModGuts)
 generateCore runSimplifier file = do
     packageState <- hscEnv <$> use_ GhcSessionDeps file
+    hsc' <- setFileCacheHook packageState
     tm <- use_ TypeCheck file
-    liftIO $ compileModule runSimplifier packageState (tmrModSummary tm) (tmrTypechecked tm)
+    liftIO $ compileModule runSimplifier hsc' (tmrModSummary tm) (tmrTypechecked tm)
 
 generateCoreRule :: Recorder (WithPriority Log) -> Rules ()
 generateCoreRule recorder =
@@ -909,14 +924,15 @@
       tmr <- use_ TypeCheck f
       linkableType <- getLinkableType f
       hsc <- hscEnv <$> use_ GhcSessionDeps f
+      hsc' <- setFileCacheHook hsc
       let compile = fmap ([],) $ use GenerateCore f
       se <- getShakeExtras
-      (diags, !mbHiFile) <- writeCoreFileIfNeeded se hsc linkableType compile tmr
+      (diags, !mbHiFile) <- writeCoreFileIfNeeded se hsc' linkableType compile tmr
       let fp = hiFileFingerPrint <$> mbHiFile
       hiDiags <- case mbHiFile of
         Just hiFile
           | OnDisk <- status
-          , not (tmrDeferredError tmr) -> liftIO $ writeHiFile se hsc hiFile
+          , not (tmrDeferredError tmr) -> liftIO $ writeHiFile se hsc' hiFile
         _ -> pure []
       return (fp, (diags++hiDiags, mbHiFile))
     NotFOI -> do
@@ -940,12 +956,21 @@
   count <- getRebuildCountVar <$> getIdeGlobalAction
   liftIO $ atomically $ modifyTVar' count (+1)
 
+setFileCacheHook :: HscEnv -> Action HscEnv
+setFileCacheHook old_hsc_env = do
+#if MIN_VERSION_ghc(9,11,0)
+  unlift <- askUnliftIO
+  return $ old_hsc_env { hsc_FC = (hsc_FC old_hsc_env) { lookupFileCache = unliftIO unlift . use_ GetFileHash . toNormalizedFilePath'  } }
+#else
+  return old_hsc_env
+#endif
+
 -- | Also generates and indexes the `.hie` file, along with the `.o` file if needed
 -- Invariant maintained is that if the `.hi` file was successfully written, then the
 -- `.hie` and `.o` file (if needed) were also successfully written
 regenerateHiFile :: HscEnvEq -> NormalizedFilePath -> ModSummary -> Maybe LinkableType -> Action ([FileDiagnostic], Maybe HiFileResult)
 regenerateHiFile sess f ms compNeeded = do
-    let hsc = hscEnv sess
+    hsc <- setFileCacheHook (hscEnv sess)
     opt <- getIdeOptions
 
     -- Embed haddocks in the interface file
@@ -977,8 +1002,8 @@
                     se' <- getShakeExtras
                     (gDiags, masts) <- liftIO $ generateHieAsts hsc tmr
                     source <- getSourceFileSource f
-                    wDiags <- forM masts $ \asts ->
-                      liftIO $ writeAndIndexHieFile hsc se' (tmrModSummary tmr) f (tcg_exports $ tmrTypechecked tmr) asts source
+                    wDiags <- forM masts $ \(asts, entityInfos) ->
+                      liftIO $ writeAndIndexHieFile hsc se' (tmrModSummary tmr) f (tcg_exports $ tmrTypechecked tmr) asts entityInfos source
 
                     -- We don't write the `.hi` file if there are deferred errors, since we won't get
                     -- accurate diagnostics next time if we do
@@ -1044,6 +1069,13 @@
     HiFileResult{hirModSummary, hirModIface, hirModDetails, hirCoreFp} <- use_ GetModIface f
     let obj_file  = ml_obj_file (ms_location hirModSummary)
         core_file = ml_core_file (ms_location hirModSummary)
+#if MIN_VERSION_ghc(9,11,0)
+        mkLinkable t mod l = Linkable t mod (pure l)
+        dotO o = DotO o ModuleObject
+#else
+        mkLinkable t mod l = LM t mod [l]
+        dotO = DotO
+#endif
     case hirCoreFp of
       Nothing -> error $ "called GetLinkable for a file without a linkable: " ++ show f
       Just (bin_core, fileHash) -> do
@@ -1069,10 +1101,15 @@
               else pure Nothing
             case mobj_time of
               Just obj_t
-                | obj_t >= core_t -> pure ([], Just $ HomeModInfo hirModIface hirModDetails (justObjects $ LM (posixSecondsToUTCTime obj_t) (ms_mod hirModSummary) [DotO obj_file]))
+                | obj_t >= core_t -> pure ([], Just $ HomeModInfo hirModIface hirModDetails (justObjects $ mkLinkable (posixSecondsToUTCTime obj_t) (ms_mod hirModSummary) (dotO obj_file)))
               _ -> liftIO $ coreFileToLinkable linkableType (hscEnv session) hirModSummary hirModIface hirModDetails bin_core (error "object doesn't have time")
         -- Record the linkable so we know not to unload it, and unload old versions
-        whenJust ((homeModInfoByteCode =<< hmi) <|> (homeModInfoObject =<< hmi)) $ \(LM time mod _) -> do
+        whenJust ((homeModInfoByteCode =<< hmi) <|> (homeModInfoObject =<< hmi))
+#if MIN_VERSION_ghc(9,11,0)
+          $ \(Linkable time mod _) -> do
+#else
+          $ \(LM time mod _) -> do
+#endif
             compiledLinkables <- getCompiledLinkables <$> getIdeGlobalAction
             liftIO $ modifyVar compiledLinkables $ \old -> do
               let !to_keep = extendModuleEnv old mod time
@@ -1086,7 +1123,9 @@
               --just before returning it to be loaded. This has a substantial effect on recompile
               --times as the number of loaded modules and splices increases.
               --
-              unload (hscEnv session) (map (\(mod', time') -> LM time' mod' []) $ moduleEnvToList to_keep)
+              --We use a dummy DotA linkable part to fake a NativeCode linkable.
+              --The unload function doesn't care about the exact linkable parts.
+              unload (hscEnv session) (map (\(mod', time') -> mkLinkable time' mod' (DotA "dummy")) $ moduleEnvToList to_keep)
               return (to_keep, ())
         return (fileHash <$ hmi, (warns, LinkableResult <$> hmi <*> pure fileHash))
 
@@ -1184,12 +1223,13 @@
     reportImportCyclesRule recorder
     typeCheckRule recorder
     getDocMapRule recorder
-    loadGhcSession recorder GhcSessionDepsConfig{fullModuleGraph}
+    loadGhcSession recorder def{fullModuleGraph}
     getModIfaceFromDiskRule recorder
     getModIfaceFromDiskAndIndexRule recorder
     getModIfaceRule recorder
     getModSummaryRule templateHaskellWarning recorder
     getModuleGraphRule recorder
+    getFileHashRule recorder
     knownFilesRule recorder
     getClientSettingsRule recorder
     getHieAstsRule recorder
@@ -1214,11 +1254,11 @@
 -- | Get HieFile for haskell file on NormalizedFilePath
 getHieFile :: NormalizedFilePath -> Action (Maybe HieFile)
 getHieFile nfp = runMaybeT $ do
-  HAR {hieAst} <- MaybeT $ use GetHieAst nfp
+  HAR {hieAst, entity_infos} <- MaybeT $ use GetHieAst nfp
   tmr <- MaybeT $ use TypeCheck nfp
   ghc <- MaybeT $ use GhcSession nfp
   msr <- MaybeT $ use GetModSummaryWithoutTimestamps nfp
   source <- lift $ getSourceFileSource nfp
   let exports = tcg_exports $ tmrTypechecked tmr
   typedAst <- MaybeT $ pure $ cast hieAst
-  liftIO $ runHsc (hscEnv ghc) $ mkHieFile' (msrModSummary msr) exports typedAst source
+  liftIO $ runHsc (hscEnv ghc) $ mkHieFile' (msrModSummary msr) exports typedAst entity_infos source
diff --color -ur a/src/Development/IDE/Core/Shake.hs b/src/Development/IDE/Core/Shake.hs
--- a/src/Development/IDE/Core/Shake.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Core/Shake.hs	2025-02-03 13:57:15.856468010 +0100
@@ -1247,7 +1247,7 @@
                 (mbBs, (diags, mbRes)) <- actionCatch
                     (do v <- action staleV; liftIO $ evaluate $ force v) $
                     \(e :: SomeException) -> do
-                        pure (Nothing, ([ideErrorText file (T.pack $ show e) | not $ isBadDependency e],Nothing))
+                        pure (Nothing, ([ideErrorText file (T.pack $ show key ++ show e) | not $ isBadDependency e],Nothing))
 
                 ver <- estimateFileVersionUnsafely key mbRes file
                 (bs, res) <- case mbRes of
diff --color -ur a/src/Development/IDE/GHC/CPP.hs b/src/Development/IDE/GHC/CPP.hs
--- a/src/Development/IDE/GHC/CPP.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/CPP.hs	2025-02-03 13:57:15.860467968 +0100
@@ -34,6 +34,10 @@
 import qualified GHC.SysTools.Tasks              as Pipeline
 #endif
 
+#if MIN_VERSION_ghc(9,11,0)
+import qualified GHC.SysTools.Tasks              as Pipeline
+#endif
+
 addOptP :: String -> DynFlags -> DynFlags
 addOptP f = alterToolSettings $ \s -> s
           { toolSettings_opt_P             = f : toolSettings_opt_P s
diff --color -ur a/src/Development/IDE/GHC/Compat/Core.hs b/src/Development/IDE/GHC/Compat/Core.hs
--- a/src/Development/IDE/GHC/Compat/Core.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/Compat/Core.hs	2025-02-03 13:57:15.856468010 +0100
@@ -69,6 +69,11 @@
     IfaceTyCon(..),
     ModIface,
     ModIface_(..),
+#if MIN_VERSION_ghc(9,11,0)
+    pattern ModIface,
+    set_mi_top_env,
+    set_mi_usages,
+#endif
     HscSource(..),
     WhereFrom(..),
     loadInterface,
@@ -230,7 +235,11 @@
     ModuleOrigin(..),
     PackageName(..),
     -- * Linker
+#if MIN_VERSION_ghc(9,11,0)
+    LinkablePart(..),
+#else
     Unlinked(..),
+#endif
     Linkable(..),
     unload,
     -- * Hooks
@@ -531,15 +540,25 @@
 import           GHC.Unit.Module.ModDetails
 import           GHC.Unit.Module.ModGuts
 import           GHC.Unit.Module.ModIface    (IfaceExport, ModIface,
-                                              ModIface_ (..), mi_fix)
+                                              ModIface_ (..), mi_fix
+#if MIN_VERSION_ghc(9,11,0)
+                                             , pattern ModIface
+                                             , set_mi_top_env
+                                             , set_mi_usages
+#endif
+                                             )
 import           GHC.Unit.Module.ModSummary  (ModSummary (..))
 import           GHC.Utils.Error             (mkPlainErrorMsgEnvelope)
 import           GHC.Utils.Panic
 import           GHC.Utils.TmpFs
 import           Language.Haskell.Syntax     hiding (FunDep)
 
+
 -- See Note [Guidelines For Using CPP In GHCIDE Import Statements]
 
+#if MIN_VERSION_ghc(9,11,0)
+import System.OsPath
+#endif
 
 #if !MIN_VERSION_ghc(9,7,0)
 import           GHC.Types.Avail             (greNamePrintableName)
@@ -550,7 +569,13 @@
 #endif
 
 mkHomeModLocation :: DynFlags -> ModuleName -> FilePath -> IO Module.ModLocation
+#if MIN_VERSION_ghc(9,11,0)
+mkHomeModLocation df mn f = 
+  let osf = unsafeEncodeUtf f
+  in pure $ GHC.mkHomeModLocation (GHC.initFinderOpts df) mn osf
+#else
 mkHomeModLocation df mn f = pure $ GHC.mkHomeModLocation (GHC.initFinderOpts df) mn f
+#endif
 
 pattern RealSrcSpan :: SrcLoc.RealSrcSpan -> Maybe BufSpan -> SrcLoc.SrcSpan
 
@@ -709,7 +734,7 @@
 #endif
     ,gre_par, gre_lcl, gre_imp = (toList -> gre_imp)}
 
-collectHsBindsBinders :: CollectPass p => Bag (XRec p (HsBindLR p idR)) -> [IdP p]
+collectHsBindsBinders :: CollectPass p => LHsBindsLR p idR -> [IdP p]
 collectHsBindsBinders x = GHC.collectHsBindsBinders CollNoDictBinders x
 
 
diff --git a/ghcide/src/Development/IDE/GHC/Compat/Driver.hs b/ghcide/src/Development/IDE/GHC/Compat/Driver.hs
index c88d0963d6..f71a25fe15 100644
--- a/ghcide/src/Development/IDE/GHC/Compat/Driver.hs
+++ b/ghcide/src/Development/IDE/GHC/Compat/Driver.hs
@@ -12,6 +12,12 @@ module Development.IDE.GHC.Compat.Driver
     ( hscTypecheckRenameWithDiagnostics
     ) where
 
+#if MIN_VERSION_ghc(9,11,0)
+
+import GHC.Driver.Main (hscTypecheckRenameWithDiagnostics)
+
+#else
+
 import           Control.Monad
 import           GHC.Core
 import           GHC.Data.FastString
@@ -145,3 +151,5 @@ hscSimpleIface :: HscEnv
 hscSimpleIface hsc_env tc_result summary
     = runHsc hsc_env $ hscSimpleIface' tc_result summary
 #endif
+
+#endif
diff --color -ur a/src/Development/IDE/GHC/Compat/Iface.hs b/src/Development/IDE/GHC/Compat/Iface.hs
--- a/src/Development/IDE/GHC/Compat/Iface.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/Compat/Iface.hs	2025-02-03 13:57:15.856468010 +0100
@@ -21,7 +21,11 @@
 #endif
 
 writeIfaceFile :: HscEnv -> FilePath -> ModIface -> IO ()
+#if MIN_VERSION_ghc(9,11,0)
+writeIfaceFile env fp iface = Iface.writeIface (hsc_logger env) (targetProfile $ hsc_dflags env) (Iface.flagsToIfCompression $ hsc_dflags env) fp iface
+#elif MIN_VERSION_ghc(9,3,0)
 writeIfaceFile env fp iface = Iface.writeIface (hsc_logger env) (targetProfile $ hsc_dflags env) fp iface
+#endif
 
 cannotFindModule :: HscEnv -> ModuleName -> FindResult -> SDoc
 cannotFindModule env modname fr =
diff --color -ur a/src/Development/IDE/GHC/Compat/Parser.hs b/src/Development/IDE/GHC/Compat/Parser.hs
--- a/src/Development/IDE/GHC/Compat/Parser.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/Compat/Parser.hs	2025-02-03 13:57:15.856468010 +0100
@@ -16,7 +16,6 @@
     Development.IDE.GHC.Compat.Parser.pm_mod_summary,
     Development.IDE.GHC.Compat.Parser.pm_extra_src_files,
     -- * API Annotations
-    Anno.AnnKeywordId(..),
     pattern EpaLineComment,
     pattern EpaBlockComment
     ) where
diff --color -ur a/src/Development/IDE/GHC/Compat.hs b/src/Development/IDE/GHC/Compat.hs
--- a/src/Development/IDE/GHC/Compat.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/Compat.hs	2025-02-03 13:57:15.860467968 +0100
@@ -326,9 +326,10 @@
 mkHieFile' :: ModSummary
            -> [Avail.AvailInfo]
            -> HieASTs Type
+           -> NameEntityInfo
            -> BS.ByteString
            -> Hsc HieFile
-mkHieFile' ms exports asts src = do
+mkHieFile' ms exports asts entityInfos src = do
   let Just src_file = ml_hs_file $ ms_location ms
       (asts',arr) = compressTypes asts
   return $ HieFile
@@ -339,6 +340,7 @@
       -- mkIfaceExports sorts the AvailInfos for stability
       , hie_exports = mkIfaceExports exports
       , hie_hs_src = src
+      , hie_entity_infos = entityInfos
       }
 
 addIncludePathsQuote :: FilePath -> DynFlags -> DynFlags
diff --color -ur a/src/Development/IDE/GHC/CoreFile.hs b/src/Development/IDE/GHC/CoreFile.hs
--- a/src/Development/IDE/GHC/CoreFile.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/CoreFile.hs	2025-02-03 13:57:15.860467968 +0100
@@ -26,6 +26,9 @@
 import           GHC.Fingerprint
 import           GHC.Iface.Binary
 import           GHC.Iface.Env
+#if MIN_VERSION_ghc(9,11,0)
+import qualified GHC.Iface.Load                  as Iface
+#endif
 import           GHC.Iface.Recomp.Binary         (fingerprintBinMem)
 import           GHC.IfaceToCore
 import           GHC.Types.Id.Make
@@ -87,14 +90,20 @@
     return (file, fp)
 
 -- | Write a core file
-writeBinCoreFile :: FilePath -> CoreFile -> IO Fingerprint
-writeBinCoreFile core_path fat_iface = do
+writeBinCoreFile :: DynFlags -> FilePath -> CoreFile -> IO Fingerprint
+writeBinCoreFile _dflags core_path fat_iface = do
     bh <- openBinMem initBinMemSize
 
     let quietTrace =
           QuietBinIFace
 
-    putWithUserData quietTrace bh fat_iface
+    putWithUserData
+      quietTrace
+#if MIN_VERSION_ghc(9,11,0)
+      (Iface.flagsToIfCompression _dflags)
+#endif
+      bh
+      fat_iface
 
     -- And send the result to the file
     writeBinMem bh core_path
@@ -141,7 +150,11 @@
     | (op, val_index) <- classAllSelIds cls `zip` [0..] ]
 
 get_defn :: Id -> CoreBind
-get_defn identifier = NonRec identifier (unfoldingTemplate (realIdUnfolding identifier))
+get_defn identifier = NonRec identifier templ
+  where
+    templ = case maybeUnfoldingTemplate (realIdUnfolding identifier) of
+              Nothing -> error "get_dfn: no unfolding template"
+              Just x -> x
 
 toIfaceTopBndr1 :: Module -> Id -> IfaceId
 toIfaceTopBndr1 mod identifier
diff --color -ur a/src/Development/IDE/GHC/Orphans.hs b/src/Development/IDE/GHC/Orphans.hs
--- a/src/Development/IDE/GHC/Orphans.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/GHC/Orphans.hs	2025-02-03 13:57:15.860467968 +0100
@@ -48,6 +48,17 @@
 instance NFData ModDetails where rnf = rwhnf
 instance NFData SafeHaskellMode where rnf = rwhnf
 instance Show Linkable where show = unpack . printOutputable
+#if MIN_VERSION_ghc(9,11,0)
+instance NFData Linkable where rnf (Linkable a b c) = rnf a `seq` rnf b `seq` rnf c
+instance NFData LinkableObjectSort where rnf = rwhnf
+instance NFData LinkablePart where
+  rnf (DotO a b)         = rnf a `seq` rnf b
+  rnf (DotA f)           = rnf f
+  rnf (DotDLL f)         = rnf f
+  rnf (BCOs a)           = seqCompiledByteCode a
+  rnf (CoreBindings wcb) = rnf wcb
+  rnf (LazyBCOs a b)     = seqCompiledByteCode a `seq` rnf b
+#else
 instance NFData Linkable where rnf (LM a b c) = rnf a `seq` rnf b `seq` rnf c
 instance NFData Unlinked where
   rnf (DotO f)           = rnf f
@@ -57,13 +68,23 @@
 #if MIN_VERSION_ghc(9,5,0)
   rnf (CoreBindings wcb) = rnf wcb
   rnf (LoadedBCOs us)    = rnf us
+#endif
+#endif
 
+#if MIN_VERSION_ghc(9,5,0)
 instance NFData WholeCoreBindings where
+#if MIN_VERSION_ghc(9,11,0)
+  rnf (WholeCoreBindings bs m ml f) = rnf bs `seq` rnf m `seq` rnf ml `seq` rnf f
+#else
   rnf (WholeCoreBindings bs m ml) = rnf bs `seq` rnf m `seq` rnf ml
+#endif
 
 instance NFData ModLocation where
+#if MIN_VERSION_ghc(9,11,0)
+    rnf (OsPathModLocation mf f1 f2 f3 f4 f5) = rnf mf `seq` rnf f1 `seq` rnf f2 `seq` rnf f3 `seq` rnf f4 `seq` rnf f5
+#else
     rnf (ModLocation mf f1 f2 f3 f4 f5) = rnf mf `seq` rnf f1 `seq` rnf f2 `seq` rnf f3 `seq` rnf f4 `seq` rnf f5
-
+#endif
 #endif
 
 instance Show PackageFlag where show = unpack . printOutputable
diff --color -ur a/src/Development/IDE/Import/DependencyInformation.hs b/src/Development/IDE/Import/DependencyInformation.hs
--- a/src/Development/IDE/Import/DependencyInformation.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Import/DependencyInformation.hs	2025-02-03 13:57:15.856468010 +0100
@@ -20,6 +20,7 @@
   , insertImport
   , pathToId
   , idToPath
+  , idToModLocation
   , reachableModules
   , processDependencyInformation
   , transitiveDeps
diff --color -ur a/src/Development/IDE/Import/FindImports.hs b/src/Development/IDE/Import/FindImports.hs
--- a/src/Development/IDE/Import/FindImports.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Import/FindImports.hs	2025-02-03 13:57:15.856468010 +0100
@@ -29,6 +29,10 @@
 import           System.FilePath
 
 
+#if MIN_VERSION_ghc(9,11,0)
+import           GHC.Driver.DynFlags
+#endif
+
 data Import
   = FileImport !ArtifactsLocation
   | PackageImport
@@ -96,7 +100,11 @@
 -- current module. In particular, it will return Nothing for 'main' components
 -- as they can never be imported into another package.
 mkImportDirs :: HscEnv -> (UnitId, DynFlags) -> Maybe (UnitId, ([FilePath], S.Set ModuleName))
+#if MIN_VERSION_ghc(9,11,0)
+mkImportDirs _env (i, flags) = Just (i, (importPaths flags, S.fromList $ map reexportTo $ reexportedModules flags))
+#else
 mkImportDirs _env (i, flags) = Just (i, (importPaths flags, reexportedModules flags))
+#endif
 
 -- | locate a module in either the file system or the package database. Where we go from *daml to
 -- Haskell
@@ -146,7 +154,11 @@
       -- about which module unit a imports.
       -- Without multi-component support it is hard to recontruct the dependency environment so
       -- unit a will have both unit b and unit c in scope.
+#if MIN_VERSION_ghc(9,11,0)
+      map (\uid -> let this_df = homeUnitEnv_dflags (ue_findHomeUnitEnv uid ue) in (uid, importPaths this_df, S.fromList $ map reexportTo $ reexportedModules this_df)) hpt_deps
+#else
       map (\uid -> let this_df = homeUnitEnv_dflags (ue_findHomeUnitEnv uid ue) in (uid, importPaths this_df, reexportedModules this_df)) hpt_deps
+#endif
     ue = hsc_unit_env env
     units = homeUnitEnv_units $ ue_findHomeUnitEnv (homeUnitId_ dflags) ue
     hpt_deps :: [UnitId]
diff --color -ur a/src/Development/IDE/Plugin/TypeLenses.hs b/src/Development/IDE/Plugin/TypeLenses.hs
--- a/src/Development/IDE/Plugin/TypeLenses.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Plugin/TypeLenses.hs	2025-02-03 13:57:15.860467968 +0100
@@ -1,6 +1,7 @@
 {-# LANGUAGE DeriveAnyClass   #-}
 {-# LANGUAGE OverloadedLabels #-}
 {-# LANGUAGE TypeFamilies     #-}
+{-# LANGUAGE CPP              #-}
 
 -- | An HLS plugin to provide code lenses for type signatures
 module Development.IDE.Plugin.TypeLenses (
@@ -319,7 +320,11 @@
         let name = idName identifier
         hasSig name $ do
           env <- tcInitTidyEnv
+#if MIN_VERSION_ghc(9,11,0)
+          let ty = tidyOpenType env (idType identifier)
+#else
           let (_, ty) = tidyOpenType env (idType identifier)
+#endif
           pure $ GlobalBindingTypeSig name (printName name <> " :: " <> showDoc (pprSigmaType ty)) (name `elemNameSet` exports)
       patToSig p = do
         let name = patSynName p
diff --color -ur a/src/Development/IDE/Spans/AtPoint.hs b/src/Development/IDE/Spans/AtPoint.hs
--- a/src/Development/IDE/Spans/AtPoint.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Spans/AtPoint.hs	2025-02-03 13:57:15.860467968 +0100
@@ -99,10 +99,10 @@
 foiReferencesAtPoint file pos (FOIReferences asts) =
   case HM.lookup file asts of
     Nothing -> ([],[],[])
-    Just (HAR _ hf _ _ _,mapping) ->
+    Just (HAR _ hf _ _ _ _,mapping) ->
       let names = getNamesAtPoint hf pos mapping
           adjustedLocs = HM.foldr go [] asts
-          go (HAR _ _ rf tr _, goMapping) xs = refs ++ typerefs ++ xs
+          go (HAR _ _ _ rf tr _, goMapping) xs = refs ++ typerefs ++ xs
             where
               refs = concatMap (mapMaybe (toCurrentLocation goMapping . realSrcSpanToLocation . fst))
                                (mapMaybe (\n -> M.lookup (Right n) rf) names)
@@ -238,7 +238,7 @@
   -> HscEnv
   -> Position
   -> IO (Maybe (Maybe Range, [T.Text]))
-atPoint IdeOptions{} (HAR _ (hf :: HieASTs a) rf _ (kind :: HieKind hietype)) (DKMap dm km) env pos =
+atPoint IdeOptions{} (HAR _ (hf :: HieASTs a) _ rf _ (kind :: HieKind hietype)) (DKMap dm km) env pos =
     listToMaybe <$> sequence (pointCommand hf pos hoverInfo)
   where
     -- Hover info for values/data
@@ -416,7 +416,7 @@
   -> Position
   -> HieAstResult
   -> m [(Location, Identifier)]
-typeLocationsAtPoint withHieDb lookupModule _ideOptions pos (HAR _ ast _ _ hieKind) =
+typeLocationsAtPoint withHieDb lookupModule _ideOptions pos (HAR _ ast _ _ _ hieKind) =
   case hieKind of
     HieFromDisk hf ->
       let arr = hie_types hf
@@ -464,7 +464,7 @@
   -> Position
   -> HieAstResult
   -> m [(Location, Identifier)]
-locationsAtPoint withHieDb lookupModule _ideOptions imports pos (HAR _ ast _rm _ _) =
+locationsAtPoint withHieDb lookupModule _ideOptions imports pos (HAR _ ast _ _rm _ _) =
   let ns = concat $ pointCommand ast pos (M.keys . getNodeIds)
       zeroPos = Position 0 0
       zeroRange = Range zeroPos zeroPos
@@ -484,7 +484,7 @@
   -> Position
   -> HieAstResult
   -> m [Location]
-instanceLocationsAtPoint withHieDb lookupModule _ideOptions pos (HAR _ ast _rm _ _) =
+instanceLocationsAtPoint withHieDb lookupModule _ideOptions pos (HAR _ ast _ _rm _ _) =
   let ns = concat $ pointCommand ast pos (M.keys . getNodeIds)
       evTrees = mapMaybe (eitherToMaybe >=> getEvidenceTree _rm) ns
       evNs = concatMap (map (evidenceVar) . T.flatten) evTrees
diff --color -ur a/src/Development/IDE/Types/HscEnvEq.hs b/src/Development/IDE/Types/HscEnvEq.hs
--- a/src/Development/IDE/Types/HscEnvEq.hs	2024-12-04 13:24:36.000000000 +0100
+++ b/src/Development/IDE/Types/HscEnvEq.hs	2025-02-03 13:57:15.856468010 +0100
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 module Development.IDE.Types.HscEnvEq
 (   HscEnvEq,
     hscEnv, newHscEnvEq,
@@ -22,6 +23,12 @@
 import           Development.IDE.Graph.Classes
 import           Development.IDE.Types.Exports   (ExportsMap, createExportsMap)
 import           OpenTelemetry.Eventlog          (withSpan)
+import           System.Directory                (makeAbsolute)
+import qualified Data.Map as M
+import Data.IORef
+import           GHC.Driver.Env                      (hsc_all_home_unit_ids)
+import           Ide.PluginUtils                 (toAbsolute)
+
 
 -- | An 'HscEnv' with equality. Two values are considered equal
 --   if they are created with the same call to 'newHscEnvEq' or
@@ -44,7 +51,32 @@
 
 -- | Wrap an 'HscEnv' into an 'HscEnvEq'.
 newHscEnvEq :: HscEnv -> IO HscEnvEq
-newHscEnvEq hscEnv = do
+newHscEnvEq hscEnv' = do
+
+    mod_cache <- newIORef emptyInstalledModuleEnv
+    file_cache <- newIORef M.empty
+    -- This finder cache is for things which are outside of things which are tracked
+    -- by HLS. For example, non-home modules, dependent object files etc
+#if MIN_VERSION_ghc(9,11,0)
+    let hscEnv = hscEnv'
+               { hsc_FC = FinderCache
+                        { flushFinderCaches = \_ -> error "GHC should never call flushFinderCaches outside the driver"
+                        , addToFinderCache  = \(GWIB im _) val -> do
+                            if moduleUnit im `elem` hsc_all_home_unit_ids hscEnv'
+                            then error "tried to add home module to FC"
+                            else atomicModifyIORef' mod_cache $ \c -> (extendInstalledModuleEnv c im val, ())
+                        , lookupFinderCache = \(GWIB im _) -> do
+                            if moduleUnit im `elem` hsc_all_home_unit_ids hscEnv'
+                            then error "tried to lookup home module from FC"
+                            else lookupInstalledModuleEnv <$> readIORef mod_cache <*> pure im
+                        , lookupFileCache = \fp -> error ("not used by HLS" ++ fp)
+                        }
+                }
+
+#else
+    let hscEnv = hscEnv'
+#endif
+
     let dflags = hsc_dflags hscEnv
 
     envUnique <- Unique.newUnique
