diff --color -urN retrie-1.2.3/Retrie/CPP.hs /retrie-1.2.3/Retrie/CPP.hs
--- retrie-1.2.3/Retrie/CPP.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/CPP.hs	2024-08-30 16:14:52.380653557 +0200
@@ -332,9 +332,13 @@
   -> Located (HsModule GhcPs)     -- ^ target module
   -> TransformT m (Located (HsModule GhcPs))
 #endif
-insertImports is (L l m) = do
-  imps <- graftA $ filterAndFlatten (unLoc <$> hsmodName m) is
+insertImports is (L l m') = do
+  imps' <- graftA $ filterAndFlatten (unLoc <$> hsmodName m') is
   let
+    (L _ m) = makeDeltaAst (L l m')
+    imps = case imps' of
+             [] -> []
+             (h:t) -> (setEntryDP h (DifferentLine 1 1):t)
     deduped = nubBy (eqImportDecl `on` unLoc) $ hsmodImports m ++ imps
   return $ L l m { hsmodImports = deduped }
 
diff --color -urN retrie-1.2.3/Retrie/Context.hs /retrie-1.2.3/Retrie/Context.hs
--- retrie-1.2.3/Retrie/Context.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Context.hs	2024-08-30 16:14:52.380653557 +0200
@@ -17,7 +17,9 @@
 import Data.Char (isDigit)
 import Data.Either (partitionEithers)
 import Data.Generics hiding (Fixity)
+#if __GLASGOW_HASKELL__ < 910
 import Data.List
+#endif
 import Data.Maybe
 
 import Retrie.AlphaEnv
@@ -65,7 +67,7 @@
     -- In left child, prec is 10, so HsApp child will NOT get paren'd
     -- In right child, prec is 11, so every child gets paren'd (unless atomic)
     updExp (OpApp _ _ op _) = c { ctxtParentPrec = HasPrec $ lookupOp op (ctxtFixityEnv c) }
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
     updExp (HsLet _ lbs _) = addInScope neverParen $ collectLocalBinders CollNoDictBinders lbs
 #else
     updExp (HsLet _ _ lbs _ _) = addInScope neverParen $ collectLocalBinders CollNoDictBinders lbs
diff --color -urN retrie-1.2.3/Retrie/ExactPrint/Annotated.hs /retrie-1.2.3/Retrie/ExactPrint/Annotated.hs
--- retrie-1.2.3/Retrie/ExactPrint/Annotated.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/ExactPrint/Annotated.hs	2024-08-30 16:14:52.380653557 +0200
@@ -36,19 +36,18 @@
   , unsafeMkA
   ) where
 
-import Control.Monad.State.Lazy hiding (fix)
+import Control.Monad.State.Lazy
+#if __GLASGOW_HASKELL__ < 910
+     hiding (fix)
+#endif
 import Data.Default as D
 
 import Data.Functor.Identity
 
 import Language.Haskell.GHC.ExactPrint hiding
-  ( -- cloneT
-    -- setEntryDP
-  -- , setEntryDPT
-  -- , transferEntryDPT
+  (
     transferEntryDP
   )
--- import Language.Haskell.GHC.ExactPrint.ExactPrint (ExactPrint(..))
 import Language.Haskell.GHC.ExactPrint.Utils
 
 import Retrie.GHC
@@ -79,6 +78,9 @@
   }
 deriving instance (Data ast) => Data (Annotated ast)
 
+instance (HasLoc ast) => HasLoc (Annotated ast) where
+    getHasLoc a = getHasLoc (astA a)
+
 instance Functor Annotated where
   fmap f Annotated{..} = Annotated{astA = f astA, ..}
 
@@ -126,6 +128,7 @@
 -- >     return [d1, d2]
 --
 graftA :: (Data ast, Monad m) => Annotated ast -> TransformT m ast
+-- TODO: this is a no-op, remove it
 graftA (Annotated x _) = return x
 
 -- | Encapsulate something in the current transformation into an 'Annotated'
@@ -153,8 +156,11 @@
     nil :: Annotated ()
     nil = mempty
 
-setEntryDPA :: (Default an)
-            => Annotated (LocatedAn an ast) -> DeltaPos -> Annotated (LocatedAn an ast)
+setEntryDPA ::
+#if __GLASGOW_HASKELL__ < 910
+            (Default an) =>
+#endif
+            Annotated (LocatedAn an ast) -> DeltaPos -> Annotated (LocatedAn an ast)
 setEntryDPA (Annotated ast s) dp = Annotated (setEntryDP ast dp) s
 
 -- | Exactprint an 'Annotated' thing.
diff --color -urN retrie-1.2.3/Retrie/ExactPrint.hs /retrie-1.2.3/Retrie/ExactPrint.hs
--- retrie-1.2.3/Retrie/ExactPrint.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/ExactPrint.hs	2024-08-30 16:14:52.380653557 +0200
@@ -24,13 +24,10 @@
   , parseType
     -- * Primitive Transformations
   , addAllAnnsT
-  -- , cloneT
-  -- , setEntryDPT
   , swapEntryDPT
   , transferAnnsT
   , transferEntryAnnsT
   , transferEntryDPT
-  -- , tryTransferEntryDPT
   , transferAnchor
     -- * Utils
   , debugDump
@@ -42,7 +39,6 @@
   , module Retrie.ExactPrint.Annotated
     -- * ghc-exactprint re-exports
   , module Language.Haskell.GHC.ExactPrint
-  -- , module Language.Haskell.GHC.ExactPrint.Annotate
   , module Language.Haskell.GHC.ExactPrint.Types
   , module Language.Haskell.GHC.ExactPrint.Utils
   , module Language.Haskell.GHC.ExactPrint.Transform
@@ -50,11 +46,11 @@
 
 import Control.Exception
 import Control.Monad
-import Control.Monad.State.Lazy hiding (fix)
--- import Data.Function (on)
+import Control.Monad.State.Lazy
+#if __GLASGOW_HASKELL__ < 910
+   hiding (fix)
+#endif
 import Data.List (transpose)
--- import Data.Maybe
--- import qualified Data.Map as M
 import Text.Printf
 
 import Language.Haskell.GHC.ExactPrint hiding
@@ -62,7 +58,6 @@
    setEntryDP
   , transferEntryDP
   )
--- import Language.Haskell.GHC.ExactPrint.ExactPrint (ExactPrint)
 import Language.Haskell.GHC.ExactPrint.Utils hiding (debug)
 import qualified Language.Haskell.GHC.ExactPrint.Parsers as Parsers
 import Language.Haskell.GHC.ExactPrint.Types
@@ -74,7 +69,9 @@
 import Retrie.Fixity
 import Retrie.GHC
 import Retrie.SYB hiding (ext1)
+-- #if __GLASGOW_HASKELL__ < 910
 import Retrie.Util
+-- #endif
 
 import GHC.Stack
 import Debug.Trace
@@ -106,33 +103,62 @@
   => FixityEnv
   -> LHsExpr GhcPs
   -> TransformT m (LHsExpr GhcPs)
-fixOneExpr env (L l2 (OpApp x2 ap1@(L l1 (OpApp x1 x op1 y)) op2 z))
+fixOneExpr env (L l2 (OpApp x2 ap1@(L _l1 (OpApp x1 x op1 y)) op2 z))
+{-
+  pre
+  x   is [print]   4:8-12
+  op1 is [$]       4:14
+  y   is [foo]     4:16-18
+  op2 is [`bar`]   4:20-24
+  z   is [[1..10]] 4:26-32
+
+  (L l2 (OpApp _
+          (L l1 (OpApp _ x op1 y))
+          op2
+          z))
+  -- post
+  (L l2 (OpApp _
+          x
+          op1
+          (L new_loc (OpApp _ y op2 z)))
+-}
+
   | associatesRight (lookupOp op1 env) (lookupOp op2 env) = do
     -- lift $ liftIO $ debugPrint Loud "fixOneExpr:(l1,l2)="  [showAst (l1,l2)]
-    let ap2' = L (stripComments l2) $ OpApp x2 y op2 z
-    (ap1_0, ap2'_0) <- swapEntryDPT ap1 ap2'
-    ap1_1 <- transferAnnsT isComma ap2'_0 ap1_0
-    -- lift $ liftIO $ debugPrint Loud "fixOneExpr:recursing"  []
+    -- We need a location from start of y to end of z
+    -- let ap2' = L (stripComments l2) $ OpApp x2 y op2 z
+    let ap2' :: LHsExpr GhcPs = L (noAnnSrcSpan (combineSrcSpans (locA y) (locA z)) ) $ OpApp x2 y op2 z
+    -- (_ap1_0, ap2'_0) <- swapEntryDPT ap1 ap2'
+    (_ap1_0, ap2'_0) <- return (ap1, ap2')
+    -- Even though we process bottom-up, we need to recurse because we
+    -- have changed the structure at this level
     rhs <- fixOneExpr env ap2'_0
     -- lift $ liftIO $ debugPrint Loud "fixOneExpr:returning"  [showAst (L l2 $ OpApp x1 x op1 rhs)]
-    -- return $ L l1 $ OpApp x1 x op1 rhs
     return $ L l2 $ OpApp x1 x op1 rhs
 fixOneExpr _ e = return e
 
 fixOnePat :: Monad m => FixityEnv -> LPat GhcPs -> TransformT m (LPat GhcPs)
-fixOnePat env (dLPat -> Just (L l2 (ConPat ext2 op2 (InfixCon (dLPat -> Just ap1@(L l1 (ConPat ext1 op1 (InfixCon x y)))) z))))
+fixOnePat env (dLPat -> Just (L l2 (ConPat x2 op2 (InfixCon (dLPat -> Just ap1@(L l1 (ConPat ext1 op1 (InfixCon x y)))) z))))
   | associatesRight (lookupOpRdrName op1 env) (lookupOpRdrName op2 env) = do
-    let ap2' = L l2 (ConPat ext2 op2 (InfixCon y z))
-    (ap1_0, ap2'_0) <- swapEntryDPT ap1 ap2'
-    ap1_1 <- transferAnnsT isComma ap2' ap1
+    -- let ap2' = L l2 (ConPat x2 op2 (InfixCon y z))
+    let ap2' = L (noAnnSrcSpan (combineSrcSpans (locA y) (locA z))) (ConPat x2 op2 (InfixCon y z))
+    -- (_ap1_0, ap2'_0) <- swapEntryDPT ap1 ap2'
+    (_ap1_0, ap2'_0) <- return (ap1, ap2')
+    -- Even though we process bottom-up, we need to recurse because we
+    -- have changed the structure at this level
     rhs <- fixOnePat env (cLPat ap2'_0)
-    return $ cLPat $ L l1 (ConPat ext1 op1 (InfixCon x rhs))
+    return $ cLPat $ L l2 (ConPat ext1 op1 (InfixCon x rhs))
 fixOnePat _ e = return e
 
 -- TODO: move to ghc-exactprint
+#if __GLASGOW_HASKELL__ >= 910
+stripComments :: EpAnn an -> EpAnn an
+stripComments (EpAnn anc an _) = EpAnn anc an emptyComments
+#else
 stripComments :: SrcAnn an -> SrcAnn an
 stripComments (SrcSpanAnn EpAnnNotUsed l) = SrcSpanAnn EpAnnNotUsed l
 stripComments (SrcSpanAnn (EpAnn anc an _) l) = SrcSpanAnn (EpAnn anc an emptyComments) l
+#endif
 
 -- Move leading whitespace from the left child of an operator application
 -- to the application itself. We need this so we have correct offsets when
@@ -144,25 +170,6 @@
   -> LocatedA a -- ^ Left child
   -> TransformT m (LocatedA a, LocatedA a)
 fixOneEntry e x = do
-  -- lift $ liftIO $ debugPrint Loud "fixOneEntry:(e,x)="  [showAst (e,x)]
-  -- -- anns <- getAnnsT
-  -- let
-  --   zeros = SameLine 0
-  --   (xdp, ard) =
-  --     case M.lookup (mkAnnKey x) anns of
-  --       Nothing -> (zeros, zeros)
-  --       Just ann -> (annLeadingCommentEntryDelta ann, annEntryDelta ann)
-  --   xr = getDeltaLine xdp
-  --   xc = deltaColumn xdp
-  --   actualRow = getDeltaLine ard
-  --   edp =
-  --     maybe zeros annLeadingCommentEntryDelta $ M.lookup (mkAnnKey e) anns
-  --   er = getDeltaLine edp
-  --   ec = deltaColumn edp
-  -- when (actualRow == 0) $ do
-  --   setEntryDPT e $ deltaPos (er, xc + ec)
-  --   setEntryDPT x $ deltaPos (xr, 0)
-
   -- We assume that ghc-exactprint has converted all Anchor's to use their delta variants.
   -- Get the dp for the x component
   let xdp = entryDP x
@@ -173,86 +180,71 @@
   let er = getDeltaLine edp
   let ec = deltaColumn edp
   case xdp of
-    SameLine n -> do
-      -- lift $ liftIO $ debugPrint Loud "fixOneEntry:(xdp,edp)="  [showAst (xdp,edp)]
-      -- lift $ liftIO $ debugPrint Loud "fixOneEntry:(dpx,dpe)="  [showAst ((deltaPos er (xc + ec)),(deltaPos xr 0))]
-      -- lift $ liftIO $ debugPrint Loud "fixOneEntry:e'="  [showAst e]
-      -- lift $ liftIO $ debugPrint Loud "fixOneEntry:e'="  [showAst (setEntryDP e (deltaPos er (xc + ec)))]
+    SameLine _n -> do
+      lift $ liftIO $ debugPrint Loud "fixOneEntry:(xdp,edp)="  [showAst (xdp,edp)]
+      lift $ liftIO $ debugPrint Loud "fixOneEntry:(dpx,dpe)="  [showAst ((deltaPos er (xc + ec)),(deltaPos xr 0))]
+      lift $ liftIO $ debugPrint Loud "fixOneEntry:e'="  [showAst e]
+      lift $ liftIO $ debugPrint Loud "fixOneEntry:e'="  [showAst (setEntryDP e (deltaPos er (xc + ec)))]
       return ( setEntryDP e (deltaPos er (xc + ec))
              , setEntryDP x (deltaPos xr 0))
     _ -> return (e,x)
 
-  -- anns <- getAnnsT
-  -- let
-  --   zeros = DP (0,0)
-  --   (DP (xr,xc), DP (actualRow,_)) =
-  --     case M.lookup (mkAnnKey x) anns of
-  --       Nothing -> (zeros, zeros)
-  --       Just ann -> (annLeadingCommentEntryDelta ann, annEntryDelta ann)
-  --   DP (er,ec) =
-  --     maybe zeros annLeadingCommentEntryDelta $ M.lookup (mkAnnKey e) anns
-  -- when (actualRow == 0) $ do
-  --   setEntryDPT e $ DP (er, xc + ec)
-  --   setEntryDPT x $ DP (xr, 0)
-  -- return e
-
 -- TODO: move this somewhere more appropriate
 entryDP :: LocatedA a -> DeltaPos
+#if __GLASGOW_HASKELL__ >= 910
+entryDP = getEntryDP
+#else
 entryDP (L (SrcSpanAnn EpAnnNotUsed _) _) = SameLine 1
 entryDP (L (SrcSpanAnn (EpAnn anc _ _) _) _)
   = case anchor_op anc of
       UnchangedAnchor -> SameLine 1
       MovedAnchor dp -> dp
+#endif
 
 
 fixOneEntryExpr :: MonadIO m => LHsExpr GhcPs -> TransformT m (LHsExpr GhcPs)
-fixOneEntryExpr e@(L l (OpApp a x b c)) = do
+#if __GLASGOW_HASKELL__ >= 910
+fixOneEntryExpr e = return e
+#else
+fixOneEntryExpr e@(L _l (OpApp a x b c)) = do
   -- lift $ liftIO $ debugPrint Loud "fixOneEntryExpr:(e,x)="  [showAst (e,x)]
   (e',x') <- fixOneEntry e x
   -- lift $ liftIO $ debugPrint Loud "fixOneEntryExpr:(e',x')="  [showAst (e',x')]
   -- lift $ liftIO $ debugPrint Loud "fixOneEntryExpr:returning="  [showAst (L (getLoc e') (OpApp a x' b c))]
   return (L (getLoc e') (OpApp a x' b c))
-fixOneEntryExpr e = return e
+#endif
 
 fixOneEntryPat :: MonadIO m => LPat GhcPs -> TransformT m (LPat GhcPs)
+#if __GLASGOW_HASKELL__ >= 910
+fixOneEntryPat pat = return pat
+#else
 fixOneEntryPat pat
 #if __GLASGOW_HASKELL__ < 900
   | Just p@(L l (ConPatIn a (InfixCon x b))) <- dLPat pat = do
 #else
-  | Just p@(L l (ConPat a b (InfixCon x c))) <- dLPat pat = do
+  | Just p@(L _l (ConPat a b (InfixCon x c))) <- dLPat pat = do
 #endif
     (p', x') <- fixOneEntry p (dLPatUnsafe x)
     return (cLPat $ (L (getLoc p') (ConPat a b (InfixCon x' c))))
   | otherwise = return pat
+#endif
 
 -------------------------------------------------------------------------------
 
 
 -- Swap entryDP and prior comments between the two args
 swapEntryDPT
-  :: (Data a, Data b, Monad m, Monoid a1, Monoid a2, Typeable a1, Typeable a2)
+  :: (Data a, Data b, Monad m
+#if __GLASGOW_HASKELL__ < 910
+     , Monoid a1, Monoid a2
+#endif
+     , Typeable a1, Typeable a2)
   => LocatedAn a1 a -> LocatedAn a2 b -> TransformT m (LocatedAn a1 a, LocatedAn a2 b)
 swapEntryDPT a b = do
   b' <- transferEntryDP a b
   a' <- transferEntryDP b a
   return (a',b')
 
--- swapEntryDPT
---   :: (Data a, Data b, Monad m)
---   => LocatedAn a1 a -> LocatedAn a2 b -> TransformT m ()
--- swapEntryDPT a b =
---   modifyAnnsT $ \ anns ->
---   let akey = mkAnnKey a
---       bkey = mkAnnKey b
---       aann = fromMaybe annNone $ M.lookup akey anns
---       bann = fromMaybe annNone $ M.lookup bkey anns
---   in M.insert akey
---       aann { annEntryDelta = annEntryDelta bann
---            , annPriorComments = annPriorComments bann } $
---      M.insert bkey
---       bann { annEntryDelta = annEntryDelta aann
---            , annPriorComments = annPriorComments aann } anns
-
 -------------------------------------------------------------------------------
 
 -- Compatibility module with ghc-exactprint
@@ -269,7 +261,13 @@
 #else
       fail $ showSDoc dflags $ ppr msg
 #endif
-    Right m -> return $ unsafeMkA (makeDeltaAst m) 0
+    Right m -> return $ unsafeMkA
+#if __GLASGOW_HASKELL__ < 910
+                          (makeDeltaAst m)
+#else
+                          m
+#endif
+                          0
 
 parseContent :: Parsers.LibDir -> FixityEnv -> FilePath -> String -> IO AnnotatedModule
 parseContent libdir fixities fp =
@@ -295,9 +293,6 @@
 
 -- | Parse a 'Pat'.
 parsePattern :: Parsers.LibDir -> String -> IO AnnotatedPat
--- parsePattern libdir str = parseHelper libdir "parsePattern" p str
---   where
---     p flags fp str' = fmap dLPatUnsafe <$> Parsers.parsePattern flags fp str'
 parsePattern libdir str = parseHelper libdir "parsePattern" Parsers.parsePattern str
 
 -- | Parse a 'Stmt'.
@@ -306,7 +301,6 @@
   -- debugPrint Loud "parseStmt:for" [str]
   res <- parseHelper libdir "parseStmt" Parsers.parseStmt str
   return (setEntryDPA res (DifferentLine 1 0))
-  -- return res
 
 
 -- | Parse a 'HsType'.
@@ -324,9 +318,7 @@
 #else
     Left msg -> throwIO $ ErrorCall (showSDoc dflags $ ppr msg)
 #endif
-    Right x -> return $ unsafeMkA (makeDeltaAst x) 0
-
--- type Parser a = GHC.DynFlags -> FilePath -> String -> ParseResult a
+    Right x -> return $ unsafeMkA x 0
 
 
 -------------------------------------------------------------------------------
@@ -349,9 +341,6 @@
   putStrLn $ showAstA ax
   putStrLn "------------------------------------"
 
--- cloneT :: (Data a, Typeable a, Monad m) => a -> TransformT m a
--- cloneT e = getAnnsT >>= flip graftT e
-
 -- The following definitions are all the same as the ones from ghc-exactprint,
 -- but the types are liberalized from 'Transform a' to 'TransformT m a'.
 transferEntryAnnsT
@@ -368,113 +357,63 @@
 transferEntryDPT
   :: (HasCallStack, Data a, Data b, Monad m)
   => Located a -> Located b -> TransformT m ()
--- transferEntryDPT a b = modifyAnnsT (transferEntryDP a b)
 transferEntryDPT _a _b = error "transferEntryDPT"
 
--- tryTransferEntryDPT
---   :: (Data a, Data b, Monad m)
---   => Located a -> Located b -> TransformT m ()
--- tryTransferEntryDPT a b = modifyAnnsT $ \anns ->
---   if M.member (mkAnnKey a) anns
---     then transferEntryDP a b anns
---     else anns
-
--- This function fails if b is not in Anns, which seems dumb, since we are inserting it.
--- transferEntryDP :: (HasCallStack, Data a, Data b) => Located a -> Located b -> Anns -> Anns
--- transferEntryDP a b anns = setEntryDP b dp anns'
---   where
---     maybeAnns = do -- Maybe monad
---       anA <- M.lookup (mkAnnKey a) anns
---       let anB = M.findWithDefault annNone (mkAnnKey b) anns
---           anB' = anB { annEntryDelta = DP (0,0) }
---       return (M.insert (mkAnnKey b) anB' anns, annLeadingCommentEntryDelta anA)
---     (anns',dp) = fromMaybe
---                   (error $ "transferEntryDP: lookup failed: " ++ show (mkAnnKey a))
---                   maybeAnns
 
 addAllAnnsT
-  :: (HasCallStack, Monoid an, Data a, Data b, MonadIO m, Typeable an)
+  :: (HasCallStack
+#if __GLASGOW_HASKELL__ < 910
+     , Monoid an
+#endif
+     , Data a, Data b, MonadIO m, Typeable an)
   => LocatedAn an a -> LocatedAn an b -> TransformT m (LocatedAn an b)
 addAllAnnsT a b = do
   -- AZ: to start with, just transfer the entry DP from a to b
   transferEntryDP a b
 
 
--- addAllAnnsT
---   :: (HasCallStack, Data a, Data b, Monad m)
---   => Located a -> Located b -> TransformT m ()
--- addAllAnnsT a b = modifyAnnsT (addAllAnns a b)
-
--- addAllAnns :: (HasCallStack, Data a, Data b) => Located a -> Located b -> Anns -> Anns
--- addAllAnns a b anns =
---   fromMaybe
---     (error $ "addAllAnns: lookup failed: " ++ show (mkAnnKey a)
---       ++ " or " ++ show (mkAnnKey b))
---     $ do ann <- M.lookup (mkAnnKey a) anns
---          case M.lookup (mkAnnKey b) anns of
---            Just ann' -> return $ M.insert (mkAnnKey b) (ann `annAdd` ann') anns
---            Nothing -> return $ M.insert (mkAnnKey b) ann anns
---   where annAdd ann ann' = ann'
---           { annEntryDelta = annEntryDelta ann
---           , annPriorComments = ((++) `on` annPriorComments) ann ann'
---           , annFollowingComments = ((++) `on` annFollowingComments) ann ann'
---           , annsDP = ((++) `on` annsDP) ann ann'
---           }
-
-transferAnchor :: LocatedA a -> LocatedA b -> LocatedA b
+transferAnchor :: ExactPrint b => LocatedA a -> LocatedA b -> LocatedA b
+#if __GLASGOW_HASKELL__ >= 910
+transferAnchor (L (EpAnn anc _ _) _) lb = setAnnotationAnchor lb anc [] emptyComments
+#else
 transferAnchor (L (SrcSpanAnn EpAnnNotUsed l)    _) lb = setAnchorAn lb (spanAsAnchor l) emptyComments
 transferAnchor (L (SrcSpanAnn (EpAnn anc _ _) _) _) lb = setAnchorAn lb anc              emptyComments
+#endif
 
 
 isComma :: TrailingAnn -> Bool
 isComma (AddCommaAnn _) = True
 isComma _ = False
 
-isCommentKeyword :: AnnKeywordId -> Bool
--- isCommentKeyword (AnnComment _) = True
-isCommentKeyword _ = False
-
--- isCommentAnnotation :: Annotation -> Bool
--- isCommentAnnotation Ann{..} =
---   (not . null $ annPriorComments)
---   || (not . null $ annFollowingComments)
---   || any (isCommentKeyword . fst) annsDP
+-- isCommentKeyword :: AnnKeywordId -> Bool
+-- isCommentKeyword _ = False
+
 
 hasComments :: LocatedAn an a -> Bool
+#if __GLASGOW_HASKELL__ >= 910
+hasComments (L (EpAnn _anc _ cs) _)
+#else
 hasComments (L (SrcSpanAnn EpAnnNotUsed _) _) = False
 hasComments (L (SrcSpanAnn (EpAnn anc _ cs) _) _)
+#endif
   = case cs of
       EpaComments [] -> False
       EpaCommentsBalanced [] [] -> False
       _ -> True
 
--- hasComments :: (Data a, Monad m) => Located a -> TransformT m Bool
--- hasComments e = do
---   anns <- getAnnsT
---   let b = isCommentAnnotation <$> M.lookup (mkAnnKey e) anns
---   return $ fromMaybe False b
-
--- transferAnnsT
---   :: (Data a, Data b, Monad m)
---   => (KeywordId -> Bool)        -- transfer Anns matching predicate
---   -> Located a                  -- from
---   -> Located b                  -- to
---   -> TransformT m ()
--- transferAnnsT p a b = modifyAnnsT f
---   where
---     bKey = mkAnnKey b
---     f anns = fromMaybe anns $ do
---       anA <- M.lookup (mkAnnKey a) anns
---       anB <- M.lookup bKey anns
---       let anB' = anB { annsDP = annsDP anB ++ filter (p . fst) (annsDP anA) }
---       return $ M.insert bKey anB' anns
-
 transferAnnsT
   :: (Data a, Data b, Monad m)
   => (TrailingAnn -> Bool)      -- transfer Anns matching predicate
   -> LocatedA a                 -- from
   -> LocatedA b                 -- to
   -> TransformT m (LocatedA b)
+#if __GLASGOW_HASKELL__ >= 910
+transferAnnsT p (L (EpAnn _anc (AnnListItem ts) _cs) _a) (L an b) = do
+  let ps = filter p ts
+  let an' = case an of
+        EpAnn ancb (AnnListItem tsb) csb -> EpAnn ancb (AnnListItem (tsb++ps)) csb
+  return (L an' b)
+#else
 transferAnnsT p (L (SrcSpanAnn EpAnnNotUsed _) _) b = return b
 transferAnnsT p (L (SrcSpanAnn (EpAnn anc (AnnListItem ts) cs) l) a) (L (SrcSpanAnn an lb) b) = do
   let ps = filter p ts
@@ -482,27 +421,7 @@
         EpAnnNotUsed -> EpAnn (spanAsAnchor lb) (AnnListItem ps) emptyComments
         EpAnn ancb (AnnListItem tsb) csb -> EpAnn ancb (AnnListItem (tsb++ps)) csb
   return (L (SrcSpanAnn an' lb) b)
-
-
--- -- | 'Transform' monad version of 'setEntryDP',
--- --   which sets the entry 'DeltaPos' for an annotation.
--- setEntryDPT
---   :: (Data a, Monad m)
---   => Located a -> DeltaPos -> TransformT m ()
--- setEntryDPT ast dp = do
---   modifyAnnsT (setEntryDP ast dp)
-
--- -- | Set the true entry 'DeltaPos' from the annotation of a
--- --   given AST element.
--- setEntryDP :: Data a => Located a -> DeltaPos -> Anns -> Anns
--- --  The setEntryDP that comes with exactprint does some really confusing
--- --  entry math around comments that I'm unconvinced is either correct or useful.
--- setEntryDP x dp anns = M.alter (Just . f . fromMaybe annNone) k anns
---   where
---     k = mkAnnKey x
---     f ann = case annPriorComments ann of
---               []       -> ann { annEntryDelta = dp }
---               (c,_):cs -> ann { annPriorComments = (c,dp):cs }
+#endif
 
 -- Useful for figuring out what annotations should be on something.
 -- If you don't care about fixities, pass 'mempty' as the FixityEnv.
@@ -514,7 +433,11 @@
   case r of
     Left _ -> putStrLn "parse failed"
     Right modl -> do
+#if __GLASGOW_HASKELL__ < 910
       let m = unsafeMkA (makeDeltaAst modl) 0
+#else
+      let m = unsafeMkA modl 0
+#endif
       putStrLn "parseModule"
       debugDump m
       void $ transformDebug m
diff --color -urN retrie-1.2.3/Retrie/Expr.hs /retrie-1.2.3/Retrie/Expr.hs
--- retrie-1.2.3/Retrie/Expr.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Expr.hs	2024-08-30 16:14:52.380653557 +0200
@@ -27,8 +27,6 @@
   , parenifyT
   , parenifyP
   , patToExpr
-  -- , patToExprA
-  -- , setAnnsFor
   , unparen
   , unparenP
   , unparenT
@@ -37,34 +35,30 @@
 
 import Control.Monad
 import Control.Monad.State.Lazy
+#if __GLASGOW_HASKELL__ < 910
 import Data.Functor.Identity
--- import qualified Data.Map as M
 import Data.Maybe
--- import Data.Void
 
 import Retrie.AlphaEnv
-import Retrie.ExactPrint
+#endif
+
+import Retrie.ExactPrint hiding (d1)
 import Retrie.Fixity
 import Retrie.GHC
 import Retrie.SYB
 import Retrie.Types
+-- #if __GLASGOW_HASKELL__ < 910
 import Retrie.Util
+-- #endif
 
 -------------------------------------------------------------------------------
 
 mkLocatedHsVar :: Monad m => LocatedN RdrName -> TransformT m (LHsExpr GhcPs)
-mkLocatedHsVar ln@(L l n) = do
-  -- This special casing for [] is gross, but this is apparently how the
-  -- annotations work.
-  -- let anns =
-  --       case occNameString (occName (unLoc v)) of
-  --         "[]" -> [(G AnnOpenS, DP (0,0)), (G AnnCloseS, DP (0,0))]
-  --         _    -> [(G AnnVal, DP (0,0))]
-  -- r <- setAnnsFor v anns
-  -- return (L (moveAnchor l)  (HsVar noExtField n))
-  mkLocA (SameLine 0)  (HsVar noExtField (L (setMoveAnchor (SameLine 0) l) n))
+mkLocatedHsVar (L l n)
+  = mkLocA (SameLine 0)  (HsVar noExtField (L (setMoveAnchor (SameLine 0) l) n))
 
 -- TODO: move to ghc-exactprint
+#if __GLASGOW_HASKELL__ < 910
 setMoveAnchor :: (Monoid an) => DeltaPos -> SrcAnn an -> SrcAnn an
 setMoveAnchor dp (SrcSpanAnn EpAnnNotUsed l)
   = SrcSpanAnn (EpAnn (dpAnchor l dp) mempty emptyComments) l
@@ -75,31 +69,49 @@
 dpAnchor :: SrcSpan -> DeltaPos -> Anchor
 dpAnchor l dp = Anchor (realSrcSpan l) (MovedAnchor dp)
 
--------------------------------------------------------------------------------
+#else
+setMoveAnchor :: DeltaPos -> EpAnn an -> EpAnn an
+setMoveAnchor _dp ep@(EpAnn (EpaSpan _) _an _cs)
+  = ep
+setMoveAnchor dp (EpAnn (EpaDelta _ cs1) an cs)
+  = (EpAnn (EpaDelta dp cs1) an cs)
+#endif
+
 
--- setAnnsFor :: (Data e, Monad m)
---            => Located e -> [(KeywordId, DeltaPos)] -> TransformT m (Located e)
--- setAnnsFor e anns = modifyAnnsT (M.alter f (mkAnnKey e)) >> return e
---   where f Nothing  = Just annNone { annsDP = anns }
---         f (Just a) = Just a { annsDP = M.toList
---                                      $ M.union (M.fromList anns)
---                                                (M.fromList (annsDP a)) }
+-------------------------------------------------------------------------------
 
 mkLoc :: (Data e, Monad m) => e -> TransformT m (Located e)
 mkLoc e = do
   L <$> uniqueSrcSpanT <*> pure e
 
 -- ++AZ++:TODO: move to ghc-exactprint
-mkLocA :: (Data e, Monad m, Monoid an)
+mkLocA :: (Data e, Monad m
+#if __GLASGOW_HASKELL__ >= 910
+          , NoAnn an
+#else
+          , Monoid an
+#endif
+          )
   => DeltaPos -> e -> TransformT m (LocatedAn an e)
-mkLocA dp e = mkLocAA dp mempty e
+mkLocA dp e = mkLocAA dp
+#if __GLASGOW_HASKELL__ >= 910
+                      noAnn
+#else
+                      mempty
+#endif
+                      e
 
 -- ++AZ++:TODO: move to ghc-exactprint
 mkLocAA :: (Data e, Monad m) => DeltaPos -> an -> e -> TransformT m (LocatedAn an e)
 mkLocAA dp an e = do
+#if __GLASGOW_HASKELL__ < 910
   l <- uniqueSrcSpanT
   let anc = Anchor (realSrcSpan l) (MovedAnchor dp)
   return (L (SrcSpanAnn (EpAnn anc an emptyComments) l) e)
+#else
+  let anc = EpaDelta dp []
+  return (L (EpAnn anc an emptyComments) e)
+#endif
 
 
 -- ++AZ++:TODO: move to ghc-exactprint
@@ -110,8 +122,12 @@
 
 mkAnchor :: Monad m => DeltaPos -> TransformT m (Anchor)
 mkAnchor dp = do
+#if __GLASGOW_HASKELL__ < 910
   l <- uniqueSrcSpanT
   return (Anchor (realSrcSpan l) (MovedAnchor dp))
+#else
+  return (EpaDelta dp [])
+#endif
 
 -------------------------------------------------------------------------------
 
@@ -122,24 +138,46 @@
 mkLams [] e = return e
 mkLams vs e = do
   ancg <- mkAnchor (SameLine 0)
+#if __GLASGOW_HASKELL__ < 910
   ancm <- mkAnchor (SameLine 0)
+#endif
   let
     ga = GrhsAnn Nothing (AddEpAnn AnnRarrow (EpaDelta (SameLine 1) []))
     ang = EpAnn ancg ga emptyComments
-    anm = EpAnn ancm [(AddEpAnn AnnLam (EpaDelta (SameLine 0) []))] emptyComments
-    L l (Match x ctxt pats (GRHSs cs grhs binds)) = mkMatch LambdaExpr vs e emptyLocalBinds
+    anm =
+#if __GLASGOW_HASKELL__ < 910
+      EpAnn ancm [(AddEpAnn AnnLam (EpaDelta (SameLine 0) []))] emptyComments
+#else
+      [(AddEpAnn AnnLam (EpaDelta (SameLine 0) []))]
+#endif
+    L l (Match _x ctxt pats (GRHSs cs grhs binds)) = mkMatch
+#if __GLASGOW_HASKELL__ < 910
+                                                      LambdaExpr
+#else
+                                                      (LamAlt LamSingle)
+#endif
+                                                      vs e emptyLocalBinds
     grhs' = case grhs of
-      [L lg (GRHS an guards rhs)] -> [L lg (GRHS ang guards rhs)]
+      [L lg (GRHS _an guards rhs)] -> [L lg (GRHS ang guards rhs)]
       _ -> fail "mkLams: lambda expression can only have a single grhs!"
   matches <- mkLocA (SameLine 0) [L l (Match anm ctxt pats (GRHSs cs grhs' binds))]
   let
     mg =
 #if __GLASGOW_HASKELL__ < 908
       mkMatchGroup Generated matches
-#else
+#elif __GLASGOW_HASKELL__ < 910
       mkMatchGroup (Generated SkipPmc) matches
+#else
+      mkMatchGroup (Generated OtherExpansion SkipPmc) matches
+#endif
+  mkLocA (SameLine 1) $ HsLam
+#if __GLASGOW_HASKELL__ >= 910
+                              []
+                              LamSingle
+#else
+                              noExtField
 #endif
-  mkLocA (SameLine 1) $ HsLam noExtField mg
+                              mg
 
 mkLet :: Monad m => HsLocalBinds GhcPs -> LHsExpr GhcPs -> TransformT m (LHsExpr GhcPs)
 mkLet EmptyLocalBinds{} e = return e
@@ -153,10 +191,16 @@
   le <- mkLocA (SameLine 1) $ HsLet an lbs e
   return le
 #else
+#if __GLASGOW_HASKELL__ < 910
   an <- mkEpAnn (DifferentLine 1 5) NoEpAnns
   let tokLet = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
       tokIn = L (TokenLoc (EpaDelta (DifferentLine 1 1) [])) HsTok
   le <- mkLocA (SameLine 1) $ HsLet an tokLet lbs tokIn e
+#else
+  let tokLet = EpTok (EpaDelta (SameLine 0) [])
+      tokIn = EpTok (EpaDelta (DifferentLine 1 1) [])
+  le <- mkLocA (SameLine 1) $ HsLet (tokLet, tokIn) lbs e
+#endif
   return le
 #endif
 
@@ -164,7 +208,13 @@
 mkApps e []     = return e
 mkApps f (a:as) = do
   -- lift $ liftIO $ debugPrint Loud "mkApps:f="  [showAst f]
-  f' <- mkLocA (SameLine 0) (HsApp noAnn f a)
+  f' <- mkLocA (SameLine 0) (HsApp
+#if __GLASGOW_HASKELL__ >= 910
+                              NoExtField
+#else
+                              noAnn
+#endif
+                              f a)
   mkApps f' as
 
 -- GHC never generates HsAppTy in the parser, using HsAppsTy to keep a list
@@ -177,23 +227,19 @@
 mkTyVar nm = do
   tv <- mkLocA (SameLine 1) (HsTyVar noAnn NotPromoted nm)
   -- _ <- setAnnsFor nm [(G AnnVal, DP (0,0))]
-  (tv', nm') <- swapEntryDPT tv nm
+  (tv', _nm') <- swapEntryDPT tv nm
   return tv'
 
 mkVarPat :: Monad m => LocatedN RdrName -> TransformT m (LPat GhcPs)
 mkVarPat nm = cLPat <$> mkLocA (SameLine 1) (VarPat noExtField nm)
 
--- type HsConPatDetails p = HsConDetails (HsPatSigType (NoGhcTc p)) (LPat p) (HsRecFields p (LPat p))
-
 mkConPatIn
   :: Monad m
   => LocatedN RdrName
   -> HsConPatDetails GhcPs
-  -- -> HsConDetails Void (LocatedN RdrName) [RecordPatSynField GhcPs]
   -> TransformT m (LPat GhcPs)
 mkConPatIn patName params = do
   p <- mkLocA (SameLine 0) $ ConPat noAnn patName params
-  -- setEntryDPT p (DP (0,0))
   return p
 
 -------------------------------------------------------------------------------
@@ -221,19 +267,12 @@
 wildSupply :: [RdrName] -> [RdrName]
 wildSupply used = wildSupplyP (`notElem` used)
 
-wildSupplyAlphaEnv :: AlphaEnv -> [RdrName]
-wildSupplyAlphaEnv env = wildSupplyP (\ nm -> isNothing (lookupAlphaEnv nm env))
-
 wildSupplyP :: (RdrName -> Bool) -> [RdrName]
 wildSupplyP p =
   [ r | i <- [0..]
       , let r = mkVarUnqual (mkFastString ('w' : show (i :: Int)))
       , p r ]
 
--- patToExprA :: AlphaEnv -> AnnotatedPat -> AnnotatedHsExpr
--- patToExprA env pat = runIdentity $ transformA pat $ \ p ->
---   fst <$> runStateT (patToExpr $ cLPat p) (wildSupplyAlphaEnv env, [])
-
 patToExpr :: MonadIO m => LPat GhcPs -> PatQ m (LHsExpr GhcPs)
 patToExpr orig = case dLPat orig of
   Nothing -> error "patToExpr: called on unlocated Pat!"
@@ -259,36 +298,61 @@
     go (ListPat _ ps) = do
       ps' <- mapM patToExpr ps
       lift $ do
-        an <- mkEpAnn (SameLine 1)
-                      (AnnList Nothing (Just (AddEpAnn AnnOpenS d0)) (Just (AddEpAnn AnnCloseS d0)) [] [])
+        let al = (AnnList Nothing (Just (AddEpAnn AnnOpenS d0)) (Just (AddEpAnn AnnCloseS d0)) [] [])
+#if __GLASGOW_HASKELL__ < 910
+        an <- mkEpAnn (SameLine 1) al
         el <- mkLocA (SameLine 1) $ ExplicitList an ps'
-        -- setAnnsFor el [(G AnnOpenS, DP (0,0)), (G AnnCloseS, DP (0,0))]
+#else
+        el <- mkLocA (SameLine 1) $ ExplicitList al ps'
+#endif
         return el
     go (LitPat _ lit) = lift $ do
       -- lit' <- cloneT lit
-      mkLocA (SameLine 1) $ HsLit noAnn lit
+      mkLocA (SameLine 1) $ HsLit
+#if __GLASGOW_HASKELL__ >= 910
+                              NoExtField
+#else
+                              noAnn
+#endif
+                              lit
     go (NPat _ llit mbNeg _) = lift $ do
-      -- L _ lit <- cloneT llit
-      e <- mkLocA (SameLine 1) $ HsOverLit noAnn (unLoc llit)
+      e <- mkLocA (SameLine 1) $ HsOverLit
+#if __GLASGOW_HASKELL__ >= 910
+                                   NoExtField
+#else
+                                   noAnn
+#endif
+                                   (unLoc llit)
       negE <- maybe (return e) (mkLocA (SameLine 0) . NegApp noAnn e) mbNeg
-      -- addAllAnnsT llit negE
       return negE
 #if __GLASGOW_HASKELL__ < 904
     go (ParPat an p') = do
       p <- patToExpr p'
       lift $ mkLocA (SameLine 1) (HsPar an p)
-#else
+#elif __GLASGOW_HASKELL__ < 910
     go (ParPat an _ p' _) = do
       p <- patToExpr p'
       let tokLP = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
           tokRP = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
       lift $ mkLocA (SameLine 1) (HsPar an tokLP p tokRP)
+#else
+    go (ParPat _an p') = do
+      p <- patToExpr p'
+      let tokLP = EpTok (EpaDelta (SameLine 0) [])
+          tokRP = EpTok (EpaDelta (SameLine 0) [])
+      lift $ mkLocA (SameLine 1) (HsPar (tokLP, tokRP) p)
 #endif
     go SigPat{} = error "patToExpr SigPat"
     go (TuplePat an ps boxity) = do
       es <- forM ps $ \pat -> do
         e <- patToExpr pat
-        return $ Present noAnn e
+        return $ Present
+#if __GLASGOW_HASKELL__ >= 910
+                   NoExtField
+#else
+                   noAnn
+#endif
+                   e
       lift $ mkLocA (SameLine 1) $ ExplicitTuple an es boxity
     go (VarPat _ i) = lift $ mkLocatedHsVar i
     go AsPat{} = error "patToExpr AsPat"
@@ -307,7 +371,7 @@
                          <*> patToExpr x
                          <*> lift (mkLocatedHsVar con)
                          <*> patToExpr y
-conPatHelper con (PrefixCon tyargs xs) = do
+conPatHelper con (PrefixCon _tyargs xs) = do
   f <- lift $ mkLocatedHsVar con
   as <- mapM patToExpr xs
   -- lift $ lift $ liftIO $ debugPrint Loud "conPatHelper:f="  [showAst f]
@@ -319,7 +383,9 @@
 grhsToExpr :: LGRHS GhcPs (LHsExpr GhcPs) -> LHsExpr GhcPs
 grhsToExpr (L _ (GRHS _ [] e)) = e
 grhsToExpr (L _ (GRHS _ (_:_) e)) = e -- not sure about this
+#if __GLASGOW_HASKELL__ < 910
 grhsToExpr _ = error "grhsToExpr"
+#endif
 
 -------------------------------------------------------------------------------
 
@@ -333,16 +399,24 @@
 precedence _        _                = Nothing
 
 parenify
-  :: Monad m => Context -> LHsExpr GhcPs -> TransformT m (LHsExpr GhcPs)
-parenify Context{..} le@(L _ e)
+  :: MonadIO m => Context -> LHsExpr GhcPs -> TransformT m (LHsExpr GhcPs)
+parenify Context{..} le@(L ll e)
 #if __GLASGOW_HASKELL__ < 904
   | needed ctxtParentPrec (precedence ctxtFixityEnv e) && needsParens e =
     mkParen' (getEntryDP le) (\an -> HsPar an (setEntryDP le (SameLine 0)))
-#else
+#elif __GLASGOW_HASKELL__ < 910
   | needed ctxtParentPrec (precedence ctxtFixityEnv e) && needsParens e = do
     let tokLP = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
         tokRP = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
-     in mkParen' (getEntryDP le) (\an -> HsPar an tokLP (setEntryDP le (SameLine 0)) tokRP)
+    in mkParen' (getEntryDP le) (\an -> HsPar an tokLP (setEntryDP le (SameLine 0)) tokRP)
+#else
+  | needed ctxtParentPrec (precedence ctxtFixityEnv e) && needsParens e = do
+    let tokLP = EpTok (EpaDelta (SameLine 0) [])
+        tokRP = EpTok (EpaDelta (SameLine 0) [])
+     -- in mkParen' (getEntryDP le) (\_an -> HsPar (tokLP, tokRP) (setEntryDP le (SameLine 0)))
+    let le' = setEntryDP le (SameLine 0) :: LHsExpr GhcPs
+    let r = L ll (HsPar (tokLP, tokRP) le') :: LHsExpr GhcPs
+    return r
 #endif
   | otherwise = return le
   where
@@ -353,12 +427,13 @@
     needed _ Nothing = True
     needed _ _ = False
 
+
 getUnparened :: Data k => k -> k
 getUnparened = mkT unparen `extT` unparenT `extT` unparenP
 
 -- TODO: what about comments?
 unparen :: LHsExpr GhcPs -> LHsExpr GhcPs
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
 unparen (L _ (HsPar _ e)) = e
 #else
 unparen (L _ (HsPar _ _ e _)) = e
@@ -369,14 +444,21 @@
 needsParens :: HsExpr GhcPs -> Bool
 needsParens = hsExprNeedsParens (PprPrec 10)
 
-mkParen :: (Data x, Monad m, Monoid an, Typeable an)
-  => (LocatedAn an x -> x) -> LocatedAn an x -> TransformT m (LocatedAn an x)
-mkParen k e = do
-  pe <- mkLocA (SameLine 1) (k e)
-  -- _ <- setAnnsFor pe [(G AnnOpenP, DP (0,0)), (G AnnCloseP, DP (0,0))]
-  (e0,pe0) <- swapEntryDPT e pe
-  return pe0
+-- mkParen :: (Data x, Monad m
+-- #if __GLASGOW_HASKELL__ >= 910
+--            , NoAnn an
+-- #else
+--            , Monoid an
+-- #endif
+--            , Typeable an)
+--   => (LocatedAn an x -> x) -> LocatedAn an x -> TransformT m (LocatedAn an x)
+-- mkParen k e = do
+--   pe <- mkLocA (SameLine 1) (k e)
+--   -- _ <- setAnnsFor pe [(G AnnOpenP, DP (0,0)), (G AnnCloseP, DP (0,0))]
+--   (e0,pe0) <- swapEntryDPT e pe
+--   return pe0
 
+-- TODO: rename mkParen' to mkParen
 #if __GLASGOW_HASKELL__ < 904
 mkParen' :: (Data x, Monad m, Monoid an)
          => DeltaPos -> (EpAnn AnnParen -> x) -> TransformT m (LocatedAn an x)
@@ -387,21 +469,39 @@
   pe <- mkLocA dp (k (EpAnn anc an emptyComments))
   return pe
 #else
-mkParen' :: (Data x, Monad m, Monoid an)
+mkParen' :: (Data x, Monad m
+#if __GLASGOW_HASKELL__ >= 910
+            , NoAnn an)
+#else
+            , Monoid an)
+#endif
          => DeltaPos -> (EpAnn NoEpAnns -> x) -> TransformT m (LocatedAn an x)
 mkParen' dp k = do
   let an = NoEpAnns
+#if __GLASGOW_HASKELL__ < 910
   l <- uniqueSrcSpanT
   let anc = Anchor (realSrcSpan l) (MovedAnchor (SameLine 0))
+#else
+  let anc = EpaDelta (SameLine 0) []
+#endif
   pe <- mkLocA dp (k (EpAnn anc an emptyComments))
   return pe
 
-mkParenTy :: (Data x, Monad m, Monoid an)
+mkParenTy :: (Data x, Monad m
+#if __GLASGOW_HASKELL__ >= 910
+             , NoAnn an)
+#else
+             , Monoid an)
+#endif
          => DeltaPos -> (EpAnn AnnParen -> x) -> TransformT m (LocatedAn an x)
 mkParenTy dp k = do
   let an = AnnParen AnnParens d0 d0
+#if __GLASGOW_HASKELL__ < 910
   l <- uniqueSrcSpanT
   let anc = Anchor (realSrcSpan l) (MovedAnchor (SameLine 0))
+#else
+  let anc = EpaDelta (SameLine 0) []
+#endif
   pe <- mkLocA dp (k (EpAnn anc an emptyComments))
   return pe
 #endif
@@ -419,9 +519,15 @@
 #if __GLASGOW_HASKELL__ < 904
     mkParen' (getEntryDP p) (\an -> ParPat an (setEntryDP p (SameLine 0)))
 #else
+#if __GLASGOW_HASKELL__ < 910
     let tokLP = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
         tokRP = L (TokenLoc (EpaDelta (SameLine 0) [])) HsTok
      in mkParen' (getEntryDP p) (\an -> ParPat an tokLP (setEntryDP p (SameLine 0)) tokRP)
+#else
+    let tokLP = EpTok (EpaDelta (SameLine 0) [])
+        tokRP = EpTok (EpaDelta (SameLine 0) [])
+     in mkParen' (getEntryDP p) (\_an -> ParPat (tokLP, tokRP) (setEntryDP p (SameLine 0)))
+#endif
 #endif
   | otherwise = return p
   where
@@ -448,8 +554,10 @@
   | needed ty =
 #if __GLASGOW_HASKELL__ < 904
       mkParen' (getEntryDP lty) (\an -> HsParTy an (setEntryDP lty (SameLine 0)))
-#else
+#elif __GLASGOW_HASKELL__ < 910
       mkParenTy (getEntryDP lty) (\an -> HsParTy an (setEntryDP lty (SameLine 0)))
+#else
+      mkParenTy (getEntryDP lty) (\an -> HsParTy (anns an) (setEntryDP lty (SameLine 0)))
 #endif
   | otherwise = return lty
   where
@@ -463,7 +571,7 @@
 unparenT ty = ty
 
 unparenP :: LPat GhcPs -> LPat GhcPs
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
 unparenP (L _ (ParPat _ p)) = p
 #else
 unparenP (L _ (ParPat _ _ p _)) = p
diff --color -urN retrie-1.2.3/Retrie/FreeVars.hs /retrie-1.2.3/Retrie/FreeVars.hs
--- retrie-1.2.3/Retrie/FreeVars.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/FreeVars.hs	2024-08-30 16:14:52.380653557 +0200
@@ -3,6 +3,7 @@
 -- This source code is licensed under the MIT license found in the
 -- LICENSE file in the root directory of this source tree.
 --
+{-# LANGUAGE CPP #-}
 module Retrie.FreeVars
   ( FreeVars
   , elemFVs
@@ -25,11 +26,17 @@
 emptyFVs = FreeVars emptyUniqSet
 
 instance Semigroup FreeVars where
+#if __GLASGOW_HASKELL__ < 910
   (<>) = mappend
+#else
+  (FreeVars s1) <> (FreeVars s2) = FreeVars $ s1 <> s2
+#endif
 
 instance Monoid FreeVars where
   mempty = emptyFVs
+#if __GLASGOW_HASKELL__ < 910
   mappend (FreeVars s1) (FreeVars s2) = FreeVars $ s1 <> s2
+#endif
 
 instance Show FreeVars where
   show (FreeVars m) = show (nonDetEltsUniqSet m)
diff --color -urN retrie-1.2.3/Retrie/PatternMap/Instances.hs /retrie-1.2.3/Retrie/PatternMap/Instances.hs
--- retrie-1.2.3/Retrie/PatternMap/Instances.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/PatternMap/Instances.hs	2024-08-30 16:14:52.380653557 +0200
@@ -363,10 +363,14 @@
                           (toA (mAlter env vs fl f)))) (emIf m) }
       go (HsIPVar _ (HsIPName ip)) = m { emIPVar = mAlter env vs ip f (emIPVar m) }
       go (HsLit _ l) = m { emLit   = mAlter env vs l f (emLit m) }
+#if __GLASGOW_HASKELL__ >= 910
+      go (HsLam _ _variant mg) = m { emLam   = mAlter env vs mg f (emLam m) }
+#else
       go (HsLam _ mg) = m { emLam   = mAlter env vs mg f (emLam m) }
+#endif
       go (HsOverLit _ ol) = m { emOverLit = mAlter env vs (ol_val ol) f (emOverLit m) }
       go (NegApp _ e' _) = m { emNegApp = mAlter env vs e' f (emNegApp m) }
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
       go (HsPar _ e') = m { emPar  = mAlter env vs e' f (emPar m) }
 #else
       go (HsPar _ _ e' _) = m { emPar  = mAlter env vs e' f (emPar m) }
@@ -386,7 +390,7 @@
         m { emSecL = mAlter env vs o (toA (mAlter env vs lhs f)) (emSecL m) }
       go (SectionR _ o rhs) =
         m { emSecR = mAlter env vs o (toA (mAlter env vs rhs f)) (emSecR m) }
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
       go (HsLet _ lbs e') =
 #else
       go (HsLet _ _ lbs _ e') =
@@ -396,7 +400,9 @@
           env' = foldr extendAlphaEnvInternal env bs
           vs' = vs `exceptQ` bs
         in m { emLet = mAlter env vs lbs (toA (mAlter env' vs' e' f)) (emLet m) }
+#if __GLASGOW_HASKELL__ < 910
       go HsLamCase{} = missingSyntax "HsLamCase"
+#endif
       go HsMultiIf{} = missingSyntax "HsMultiIf"
       go (ExplicitList _ es) = m { emExplicitList = mAlter env vs es f (emExplicitList m) }
       go ArithSeq{} = missingSyntax "ArithSeq"
@@ -466,10 +472,14 @@
 #endif
         mapFor emIf >=> mMatch env c >=> mMatch env tr >=> mMatch env fl
       go (HsIPVar _ (HsIPName ip)) = mapFor emIPVar >=> mMatch env ip
+#if __GLASGOW_HASKELL__ >= 910
+      go (HsLam _ _variant mg) = mapFor emLam >=> mMatch env mg
+#else
       go (HsLam _ mg) = mapFor emLam >=> mMatch env mg
+#endif
       go (HsLit _ l) = mapFor emLit >=> mMatch env l
       go (HsOverLit _ ol) = mapFor emOverLit >=> mMatch env (ol_val ol)
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
       go (HsPar _ e') = mapFor emPar >=> mMatch env e'
 #else
       go (HsPar _ _ e' _) = mapFor emPar >=> mMatch env e'
@@ -489,7 +499,7 @@
         mapFor emRecordUpd >=> mMatch env e' >=> mMatch env (fieldsToRdrNamesUpd fs)
       go (SectionL _ lhs o) = mapFor emSecL >=> mMatch env o >=> mMatch env lhs
       go (SectionR _ o rhs) = mapFor emSecR >=> mMatch env o >=> mMatch env rhs
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
       go (HsLet _ lbs e') =
 #else
       go (HsLet _ _ lbs _ e') =
@@ -701,7 +711,7 @@
   mAlter env vs d f CDEmpty   = mAlter env vs d f emptyCDMapWrapper
   mAlter env vs d f m@CDMap{} = go d
     where
-      go (PrefixCon tyargs ps) = m { cdPrefixCon = mAlter env vs ps f (cdPrefixCon m) }
+      go (PrefixCon _tyargs ps) = m { cdPrefixCon = mAlter env vs ps f (cdPrefixCon m) }
       go (RecCon _) = missingSyntax "RecCon"
       go (InfixCon p1 p2) = m { cdInfixCon = mAlter env vs p1
                                               (toA (mAlter env vs p2 f))
@@ -711,7 +721,7 @@
   mMatch _   _ (_ ,CDEmpty)   = []
   mMatch env d (hs,m@CDMap{}) = go d (hs,m)
     where
-      go (PrefixCon tyargs ps) = mapFor cdPrefixCon >=> mMatch env ps
+      go (PrefixCon _tyargs ps) = mapFor cdPrefixCon >=> mMatch env ps
       go (InfixCon p1 p2) = mapFor cdInfixCon >=> mMatch env p1 >=> mMatch env p2
       go _ = const [] -- TODO
 
@@ -785,7 +795,7 @@
       go LitPat{} = missingSyntax "LitPat"
       go NPat{} = missingSyntax "NPat"
       go NPlusKPat{} = missingSyntax "NPlusKPat"
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
       go (ParPat _ p) = m { pmParPat = mAlter env vs p f (pmParPat m) }
 #else
       go (ParPat _ _ p _) = m { pmParPat = mAlter env vs p f (pmParPat m) }
@@ -804,7 +814,7 @@
       hss lp = extendResult (pmHole m) (HolePat $ mePruneA env lp) hs
 
       go (WildPat _) = mapFor pmWild >=> mMatch env ()
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
       go (ParPat _ p) = mapFor pmParPat >=> mMatch env p
 #else
       go (ParPat _ _ p _) = mapFor pmParPat >=> mMatch env p
@@ -1393,10 +1403,17 @@
        in L l (HsFieldBind a (L l2 f') arg pun)
 fieldsToRdrNamesUpd (OverloadedRecUpdFields _ xs) = map go xs
   where
-    go (L l (HsFieldBind a (L l2 _f) arg pun)) =
+#if __GLASGOW_HASKELL__ < 910
+    go (L l (HsFieldBind a (L l2  _f) arg pun)) =
       let lrdrName = error "TBD" -- same as GHC 9.2
           f' = FieldOcc NoExtField lrdrName
        in L l (HsFieldBind a (L l2 f') arg pun)
+#else
+    go (L l (HsFieldBind a (L (EpAnn e _ c)  _f) arg pun)) =
+      let lrdrName = error "TBD" -- same as GHC 9.2
+          f' = FieldOcc NoExtField lrdrName
+       in L l (HsFieldBind a (L (EpAnn e noAnn c) f') arg pun)
+#endif
 #endif
 
 #if __GLASGOW_HASKELL__ < 904
@@ -1437,17 +1454,11 @@
   mAlter :: AlphaEnv -> Quantifiers -> Key TupleSortMap -> A a -> TupleSortMap a -> TupleSortMap a
   mAlter env vs HsUnboxedTuple f m =
     m { tsUnboxed = mAlter env vs () f (tsUnboxed m) }
-  -- mAlter env vs HsBoxedOrConstraintTuple f m =
-  --   m { tsBoxed = mAlter env vs () f (tsBoxed m) }
-  -- mAlter env vs HsConstraintTuple f m =
-  --   m { tsConstraint = mAlter env vs () f (tsConstraint m) }
   mAlter env vs HsBoxedOrConstraintTuple f m =
     m { tsBoxedOrConstraint = mAlter env vs () f (tsBoxedOrConstraint m) }
 
   mMatch :: MatchEnv -> Key TupleSortMap -> (Substitution, TupleSortMap a) -> [(Substitution, a)]
   mMatch env HsUnboxedTuple = mapFor tsUnboxed >=> mMatch env ()
-  -- mMatch env HsBoxedTuple = mapFor tsBoxed >=> mMatch env ()
-  -- mMatch env HsConstraintTuple = mapFor tsConstraint >=> mMatch env ()
   mMatch env HsBoxedOrConstraintTuple = mapFor tsBoxedOrConstraint >=> mMatch env ()
 
 ------------------------------------------------------------------------
diff --color -urN retrie-1.2.3/Retrie/Query.hs /retrie-1.2.3/Retrie/Query.hs
--- retrie-1.2.3/Retrie/Query.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Query.hs	2024-08-30 16:14:52.380653557 +0200
@@ -35,6 +35,7 @@
 parseQuerySpecs libdir' fixityEnv =
   mapM $ \(qQuantifiers, querySpec, qResult) -> do
     qPattern <- parse libdir' querySpec
+    let qOrigin = getLocU (astA qPattern)
     return Query{..}
   where
     parse libdir (QExpr s) = do
diff --color -urN retrie-1.2.3/Retrie/Replace.hs /retrie-1.2.3/Retrie/Replace.hs
--- retrie-1.2.3/Retrie/Replace.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Replace.hs	2024-08-30 16:14:52.380653557 +0200
@@ -3,6 +3,7 @@
 -- This source code is licensed under the MIT license found in the
 -- LICENSE file in the root directory of this source tree.
 --
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
@@ -57,9 +58,13 @@
     -- match under a binding of something that appears in the template.
     f result@RewriterResult{..} = result
       { rrTransformer =
-          fmap (fmap (check rrOrigin rrQuantifiers)) <$> rrTransformer
+          -- fmap (fmap (check rrOrigin rrQuantifiers)) <$> rrTransformer
+          fmap (fmap ((check rrOrigin rrQuantifiers)
+                     `debug` ("replaceImpl::(rrOrigin, getLocA e )=" ++ showGhc (rrOrigin, getLocA e) ))
+               ) <$> rrTransformer
       }
     check origin quantifiers match
+      -- if e loc is inside origin loc
       | getLocA e `overlaps` origin = NoMatch
       | MatchResult _ Template{..} <- match
       , fvs <- freeVars quantifiers (astA tTemplate)
@@ -71,7 +76,11 @@
   -- resulting expression, but we need to know the entry location
   -- of the parens, not the inner expression, so we have to
   -- keep both expressions around.
+#if __GLASGOW_HASKELL__ < 910
+  match <- runRewriter f c (ctxtRewriter c) (getUnparened $ makeDeltaAst e)
+#else
   match <- runRewriter f c (ctxtRewriter c) (getUnparened e)
+#endif
 
   case match of
     NoMatch -> return e
@@ -86,30 +95,27 @@
       res' <- (mkM (parenify c) `extM` parenifyT c `extM` parenifyP c) r0
       -- Make sure the replacement has the same anchor as the thing
       -- being replaced
-      let res = transferAnchor e res'
+      res <- transferEntryDP e res'
 
       -- prune the resulting expression and log it with location
       orig <- printNoLeadingSpaces <$> pruneA e
-      -- orig <- printA' <$> pruneA e
 
       repl <- printNoLeadingSpaces <$> pruneA res
-      -- repl <- printA' <$> pruneA r
-      -- repl <- printA' <$> pruneA res
-      -- repl <- return $ showAst t'
 
-      -- lift $ liftIO $ debugPrint Loud "replaceImpl:orig="  [orig]
-      -- lift $ liftIO $ debugPrint Loud "replaceImpl:repl="  [repl]
+      lift $ liftIO $ debugPrint Loud "replaceImpl:orig="  [orig]
+      lift $ liftIO $ debugPrint Loud "replaceImpl:repl="  [repl]
 
       -- lift $ liftIO $ debugPrint Loud "replaceImpl:e="  [showAst e]
       -- lift $ liftIO $ debugPrint Loud "replaceImpl:r="  [showAst r]
       -- lift $ liftIO $ debugPrint Loud "replaceImpl:r0="  [showAst r0]
       -- lift $ liftIO $ debugPrint Loud "replaceImpl:t'=" [showAst t']
       -- lift $ liftIO $ debugPrint Loud "replaceImpl:res=" [showAst res]
+      -- lift $ liftIO $ debugPrint Loud "replaceImpl:res=" [showAst res']
 
       let replacement = Replacement (getLocA e) orig repl
       TransformT $ lift $ tell $ Change [replacement] [tImports]
       -- make the actual replacement
-      return res'
+      return res
 
 
 -- | Records a replacement made. In cases where we cannot use ghc-exactprint
@@ -126,14 +132,23 @@
 data Change = NoChange | Change [Replacement] [AnnotatedImports]
 
 instance Semigroup Change where
+#if __GLASGOW_HASKELL__ < 910
   (<>) = mappend
+#else
+  NoChange         <> other            = other
+  other            <> NoChange         = other
+  (Change rs1 is1) <> (Change rs2 is2) =
+    Change (rs1 <> rs2) (is1 <> is2)
+#endif
 
 instance Monoid Change where
   mempty = NoChange
+#if __GLASGOW_HASKELL__ < 910
   mappend NoChange     other        = other
   mappend other        NoChange     = other
   mappend (Change rs1 is1) (Change rs2 is2) =
     Change (rs1 <> rs2) (is1 <> is2)
+#endif
 
 -- The location of 'e' accurately points to the first non-space character
 -- of 'e', but when we exactprint 'e', we might get some leading spaces (if
diff --color -urN retrie-1.2.3/Retrie/Rewrites/Function.hs /retrie-1.2.3/Retrie/Rewrites/Function.hs
--- retrie-1.2.3/Retrie/Rewrites/Function.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Rewrites/Function.hs	2024-08-30 16:14:52.380653557 +0200
@@ -38,6 +38,7 @@
         fe <- mkLocatedHsVar fRdrName
         -- lift $ debugPrint Loud "dfnsToRewrites:ef="  [showAst fe]
         imps <- getImports libdir dir (hsmodName m)
+        -- lift $ debugPrint Loud "dfnsToRewrites:imps="  [showAst imps]
         (fName,) . concat <$>
           forM (unLoc $ mg_alts $ fun_matches f) (matchToRewrites fe imps dir)
     | L _ (ValD _ f@FunBind{}) <- hsmodDecls m
@@ -62,16 +63,30 @@
   -> Direction
   -> LMatch GhcPs (LHsExpr GhcPs)
   -> TransformT IO [Rewrite (LHsExpr GhcPs)]
-matchToRewrites e imps dir (L _ alt) = do
+matchToRewrites e imps dir (L _ alt') = do
   -- lift $ debugPrint Loud "matchToRewrites:e="  [showAst e]
+  let alt = makeDeltaAst alt'
+  -- let alt = alt'
+  -- lift $ debugPrint Loud "matchToRewrites:alt="  [showAst alt]
   let
     pats = m_pats alt
     grhss = m_grhss alt
+    grhss_loc = grhssLoc alt'
+  -- lift $ debugPrint Loud "matchToRewrites:alt'="  [showAst alt']
+  lift $ debugPrint Loud "matchToRewrites:grhss_loc="  [showAst grhss_loc]
   qss <- for (zip (inits pats) (tails pats)) $
-    makeFunctionQuery e imps dir grhss mkApps
-  qs <- backtickRules e imps dir grhss pats
+    makeFunctionQuery e imps dir grhss grhss_loc mkApps
+  qs <- backtickRules e imps dir grhss grhss_loc pats
   return $ qs ++ concat qss
 
+grhssLoc :: Match GhcPs (LHsExpr GhcPs) -> SrcSpan
+grhssLoc m = loc
+    where
+      GRHSs _ grhss _ = m_grhss m
+      loc = case grhss of
+          [] -> noSrcSpan
+          (h:_) -> combineSrcSpans (getHasLoc h) (getHasLoc (last grhss))
+
 type AppBuilder =
   LHsExpr GhcPs -> [LHsExpr GhcPs] -> TransformT IO (LHsExpr GhcPs)
 
@@ -81,12 +96,12 @@
     go WildPat{} = True
     go VarPat{} = True
     go (LazyPat _ p) = irrefutablePat p
-#if __GLASGOW_HASKELL__ <= 904
+#if __GLASGOW_HASKELL__ <= 904 || __GLASGOW_HASKELL__ >= 910
     go (AsPat _ _ p) = irrefutablePat p
 #else
     go (AsPat _ _ _ p) = irrefutablePat p
 #endif
-#if __GLASGOW_HASKELL__ < 904
+#if __GLASGOW_HASKELL__ < 904 || __GLASGOW_HASKELL__ >= 910
     go (ParPat _ p) = irrefutablePat p
 #else
     go (ParPat _ _ p _) = irrefutablePat p
@@ -99,10 +114,11 @@
   -> AnnotatedImports
   -> Direction
   -> GRHSs GhcPs (LHsExpr GhcPs)
+  -> SrcSpan
   -> AppBuilder
   -> ([LPat GhcPs], [LPat GhcPs])
   -> TransformT IO [Rewrite (LHsExpr GhcPs)]
-makeFunctionQuery e imps dir grhss mkAppFn (argpats, bndpats)
+makeFunctionQuery e imps dir grhss grhss_loc mkAppFn (argpats, bndpats)
   | any (not . irrefutablePat) bndpats = return []
   | otherwise = do
     let
@@ -111,42 +127,61 @@
     -- See Note [Wildcards]
     (es,(_,bs')) <- runStateT (mapM patToExpr argpats) (wildSupply bs, bs)
     -- lift $ debugPrint Loud "makeFunctionQuery:e="  [showAst e]
+    -- lift $ debugPrint Loud "makeFunctionQuery:argpats="  [showAst argpats]
+    -- lift $ debugPrint Loud "makeFunctionQuery:es="  [showAst es]
+    -- lift $ debugPrint Loud "makeFunctionQuery:grhss_loc="  [showGhc grhss_loc]
     lhs <- mkAppFn e es
     for rhss $ \ grhs -> do
       le <- mkLet lbs (grhsToExpr grhs)
       rhs <- mkLams bndpats le
       let
-        (pat, temp) =
+        (pat, pat_loc, temp) =
           case dir of
-            LeftToRight -> (lhs,rhs)
-            RightToLeft -> (rhs,lhs)
+            LeftToRight -> (lhs, getHasLoc lhs, rhs)
+            RightToLeft -> (rhs, grhss_loc, lhs)
+      -- p <- pruneA (setEntryDP (makeDeltaAst pat) (SameLine 1))
       p <- pruneA pat
-      t <- pruneA temp
-      return $ addRewriteImports imps $ mkRewrite (mkQs bs') p t
+      t <- pruneA (setEntryDP (makeDeltaAst temp) (SameLine 1))
+      -- return $ addRewriteImports imps $ mkRewrite (mkQs bs') p (getHasLoc p) t
+      return $ addRewriteImports imps $ mkRewrite (mkQs bs') p (pat_loc
+                                                               `debug` ("makeFunctionQuery:loc" ++ (showGhc pat_loc))) t
 
 backtickRules
   :: LHsExpr GhcPs
   -> AnnotatedImports
   -> Direction
   -> GRHSs GhcPs (LHsExpr GhcPs)
+  -> SrcSpan
   -> [LPat GhcPs]
   -> TransformT IO [Rewrite (LHsExpr GhcPs)]
-backtickRules e imps dir@LeftToRight grhss ps@[p1, p2] = do
+backtickRules e imps dir@LeftToRight grhss grhss_loc ps@[p1, p2] = do
   let
     both, left, right :: AppBuilder
     both op [l, r] = mkLocA (SameLine 1) (OpApp noAnn l op r)
     both _ _ = fail "backtickRules - both: impossible!"
 
-    left op [l] = mkLocA (SameLine 1) (SectionL noAnn l op)
+    left op [l] = mkLocA (SameLine 1) (SectionL
+#if __GLASGOW_HASKELL__ >= 910
+                                         NoExtField
+#else
+                                         noAnn
+#endif
+                                         l op)
     left _ _ = fail "backtickRules - left: impossible!"
 
-    right op [r] = mkLocA (SameLine 1) (SectionR noAnn op r)
+    right op [r] = mkLocA (SameLine 1) (SectionR
+#if __GLASGOW_HASKELL__ >= 910
+                                         NoExtField
+#else
+                                         noAnn
+#endif
+                                         op r)
     right _ _ = fail "backtickRules - right: impossible!"
-  qs <- makeFunctionQuery e imps dir grhss both (ps, [])
-  qsl <- makeFunctionQuery e imps dir grhss left ([p1], [p2])
-  qsr <- makeFunctionQuery e imps dir grhss right ([p2], [p1])
+  qs <- makeFunctionQuery e imps dir grhss grhss_loc both (ps, [])
+  qsl <- makeFunctionQuery e imps dir grhss grhss_loc left ([p1], [p2])
+  qsr <- makeFunctionQuery e imps dir grhss grhss_loc right ([p2], [p1])
   return $ qs ++ qsl ++ qsr
-backtickRules _ _ _ _ _ = return []
+backtickRules _ _ _ _ _ _ = return []
 
 -- Note [fold only]
 -- Currently we only generate imports for folds, because it is easy.
diff --color -urN retrie-1.2.3/Retrie/Rewrites/Patterns.hs /retrie-1.2.3/Retrie/Rewrites/Patterns.hs
--- retrie-1.2.3/Retrie/Rewrites/Patterns.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Rewrites/Patterns.hs	2024-08-30 16:14:52.380653557 +0200
@@ -54,21 +54,39 @@
   -> LPat GhcPs
   -> TransformT IO (Rewrite (LPat GhcPs))
 mkPatRewrite dir imports patName params rhs = do
+  -- lift $ debugPrint Loud "mkPatRewrite:patName="  [showAst patName]
+  -- lift $ debugPrint Loud "mkPatRewrite:params="  [showAst params]
+  -- lift $ debugPrint Loud "mkPatRewrite:rhs="  [showAst rhs]
   lhs <- asPat patName params
+  -- lift $ debugPrint Loud "mkPatRewrite:lhs="  [showAst lhs]
 
-  (pat, temp) <- case dir of
-    LeftToRight -> return (lhs, rhs)
+  let lhs_loc = case params of
+        PrefixCon _tyargs names -> case names of
+            [] -> getHasLoc patName
+            (lp:_) -> combineSrcSpans (getHasLoc patName) (getHasLoc lp)
+        InfixCon a1 a2 -> combineSrcSpans (getHasLoc a1) (getHasLoc a2)
+        RecCon fs -> case fs of
+            [] -> getHasLoc patName
+            (lp:_) -> combineSrcSpans (getHasLoc patName) (getHasLoc (foLabel $ recordPatSynField lp))
+
+  lift $ debugPrint Loud "mkPatRewrite:lhs_loc="  [showGhc lhs_loc]
+  lift $ debugPrint Loud "mkPatRewrite:rhs_loc="  [showGhc (getHasLoc rhs)]
+
+  (pat, pat_loc, temp) <- case dir of
+    LeftToRight -> return (lhs, lhs_loc, rhs)
     RightToLeft -> do
       let lhs' = setEntryDP lhs (SameLine 0)
       -- Patterns from lhs have wonky annotations,
       -- the space will be attached to the name, not to the ConPatIn ast node
       let lhs'' = setEntryDPTunderConPatIn lhs' (SameLine 0)
-      return (rhs, lhs'')
+      return (rhs, getHasLoc rhs, lhs'')
 
+  -- TODO: make this a common function instead of pruneA
+  -- p <- pruneA (setEntryDP (makeDeltaAst pat) (SameLine 1))
   p <- pruneA pat
-  t <- pruneA temp
+  t <- pruneA (setEntryDP (makeDeltaAst temp) (SameLine 1))
   let bs = collectPatBinders CollNoDictBinders (cLPat temp)
-  return $ addRewriteImports imports $ mkRewrite (mkQs bs) p t
+  return $ addRewriteImports imports $ mkRewrite (mkQs bs) p pat_loc t
 
   where
     setEntryDPTunderConPatIn :: LPat GhcPs -> DeltaPos -> LPat GhcPs
@@ -108,10 +126,14 @@
       let hsRecFieldAnn = noAnn
       mkLocA (SameLine 0) HsRecField{..}
 #else
+#if __GLASGOW_HASKELL__ < 910
       s <- uniqueSrcSpanT
       an <- mkEpAnn (SameLine 0) NoEpAnns
       let srcspan = SrcSpanAnn an s
-          hfbLHS = L srcspan recordPatSynField
+#else
+      srcspan <- mkEpAnn (SameLine 0) noAnn
+#endif
+      let hfbLHS = L srcspan recordPatSynField
       hfbRHS <- mkVarPat recordPatSynPatVar
       let hfbPun = False
           hfbAnn = noAnn
@@ -127,6 +149,8 @@
   -> HsPatSynDir GhcPs
   -> TransformT IO [Rewrite (LHsExpr GhcPs)]
 mkExpRewrite dir imports patName params rhs patDir = do
+  -- lift $ debugPrint Loud "mkExpRewrite:params="  [showAst params]
+  -- lift $ debugPrint Loud "mkExpRewrite:rhs="  [showAst rhs]
   fe <- mkLocatedHsVar patName
   -- lift $ debugPrint Loud "mkExpRewrite:fe="  [showAst fe]
   let altsFromParams = case params of
diff --color -urN retrie-1.2.3/Retrie/Rewrites/Rules.hs /retrie-1.2.3/Retrie/Rewrites/Rules.hs
--- retrie-1.2.3/Retrie/Rewrites/Rules.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Rewrites/Rules.hs	2024-08-30 16:14:52.380653557 +0200
@@ -14,11 +14,6 @@
 import Retrie.GHC
 import Retrie.Quantifiers
 import Retrie.Types
-import Retrie.Util
-import Retrie.Monad
-import Control.Monad
-import Control.Monad.IO.Class
-import Control.Monad.Trans.Class
 
 rulesToRewrites
   :: [(FastString, Direction)]
@@ -47,7 +42,9 @@
 mkRuleRewrite RightToLeft (RuleInfo name qs lhs rhs) =
   mkRuleRewrite LeftToRight (RuleInfo name qs rhs lhs)
 mkRuleRewrite _ RuleInfo{..} = do
-  p <- pruneA (setEntryDP riLHS (SameLine 1))
-  t <- pruneA (setEntryDP riRHS (SameLine 1))
-  -- lift $ debugPrint Loud "mkRuleRewrite" [showAstA p, showAstA t]
-  return (riName, mkRewrite (mkQs riQuantifiers) p t)
+  p <- pruneA (setEntryDP (makeDeltaAst riLHS) (SameLine 1))
+  p <- pruneA riLHS
+  t <- pruneA (setEntryDP (makeDeltaAst riRHS) (SameLine 1))
+  -- lift $ debugPrint Loud "mkRuleRewrite:p,t" [showAstA p, showAstA t]
+  -- lift $ debugPrint Loud "mkRuleRewrite:riQuantifiers" [showGhc riQuantifiers]
+  return (riName, mkRewrite (mkQs riQuantifiers) p (getHasLoc p) t)
diff --color -urN retrie-1.2.3/Retrie/Rewrites/Types.hs /retrie-1.2.3/Retrie/Rewrites/Types.hs
--- retrie-1.2.3/Retrie/Rewrites/Types.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Rewrites/Types.hs	2024-08-30 16:14:52.380653557 +0200
@@ -65,5 +65,6 @@
       LeftToRight -> (lhsApps, rhs)
       RightToLeft -> (rhs, lhsApps)
   p <- pruneA pat
-  t <- pruneA tmp
-  return $ mkRewrite (mkQs $ map unLoc lvs) p t
+  t <- pruneA (setEntryDP (makeDeltaAst tmp) (SameLine 1))
+  -- return $ mkRewrite (mkQs $ map unLoc lvs) p (getHasLoc p) t
+  return $ mkRewrite (mkQs $ map unLoc lvs) p ((getHasLoc p) `debug` ("mkTypeRewrite:loc" ++ showGhc (getHasLoc p))) t
diff --color -urN retrie-1.2.3/Retrie/Run.hs /retrie-1.2.3/Retrie/Run.hs
--- retrie-1.2.3/Retrie/Run.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Run.hs	2024-08-30 16:14:52.380653557 +0200
@@ -3,6 +3,7 @@
 -- This source code is licensed under the MIT license found in the
 -- LICENSE file in the root directory of this source tree.
 --
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE TupleSections #-}
@@ -19,7 +20,9 @@
   ) where
 
 import Control.Monad
+#if __GLASGOW_HASKELL__ < 910
 import Control.Monad.State.Strict
+#endif
 import Data.Char
 import Data.List
 import Data.Monoid
@@ -107,19 +110,25 @@
   -> CPP AnnotatedModule
   -> IO b
 runOneModule writeFn Options{..} r cpp = do
-  -- debugPrint Loud "runOneModule" ["enter"]
+  debugPrint Loud "runOneModule" ["enter"]
+  -- case cpp of
+  --     NoCPP m -> debugPrint Loud "runOneModule:cpp" [showAst m]
+  --     _ -> error "wtf"
   (x, cpp', changed) <- runRetrie fixityEnv r cpp
+  -- case cpp' of
+  --     NoCPP m -> debugPrint Loud "runOneModule:cpp'" [showAst m]
+  --     _ -> error "wtf"
   case changed of
     NoChange -> return mempty
     Change repls imports -> do
       -- debugPrint Loud "runOneModule" ["change", show repls]
+      -- debugPrint Loud "runOneModule" ["additionalImports", showAst additionalImports]
       let cpp'' = addImportsCPP (additionalImports:imports) cpp'
+      -- case cpp' of
+      --     NoCPP m'' -> debugPrint Loud "runOneModule:cpp''" [showAst m'']
+      --     _ -> error "wtf"
       writeFn repls (printCPP repls cpp'') cpp'' x
 
--- isCpp :: CPP AnnotatedModule -> String
--- isCpp (NoCPP m) = "NoCPP:" ++ showAstA m
--- isCpp (CPP{}) = "CPP"
-
 -- | Write action which counts changed lines using 'diff'
 writeCountLines :: FilePath -> WriteFn a (Sum Int)
 writeCountLines fp reps str _ _ = do
diff --color -urN retrie-1.2.3/Retrie/Subst.hs /retrie-1.2.3/Retrie/Subst.hs
--- retrie-1.2.3/Retrie/Subst.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Subst.hs	2024-08-30 16:14:52.380653557 +0200
@@ -52,18 +52,16 @@
   -> TransformT m (LHsExpr GhcPs)
 substExpr ctxt e@(L l1 (HsVar x (L l2 v))) =
   case lookupHoleVar v ctxt of
-    Just (HoleExpr eA) -> do
-      -- lift $ liftIO $ debugPrint Loud "substExpr:HoleExpr:e" [showAst e]
-      -- lift $ liftIO $ debugPrint Loud "substExpr:HoleExpr:eA" [showAst eA]
+    Just (HoleExpr eA') -> do
+      let eA = fmap makeDeltaAst eA'
+      lift $ liftIO $ debugPrint Loud "substExpr:HoleExpr:e" [showAst e]
+      lift $ liftIO $ debugPrint Loud "substExpr:HoleExpr:eA" [showAst eA]
       e0 <- graftA (unparen <$> eA)
-      let comments = hasComments e0
-      -- unless comments $ transferEntryDPT e e'
-      e1 <- if comments
+      let hasCs = hasComments e0
+      e1 <- if hasCs
                then return e0
                else transferEntryDP e e0
       e2 <- transferAnnsT isComma e e1
-      -- let e'' = setEntryDP e' (SameLine 1)
-      -- lift $ liftIO $ debugPrint Loud "substExpr:HoleExpr:e2" [showAst e2]
       parenify ctxt e2
     Just (HoleRdr rdr) ->
       return $ L l1 $ HsVar x $ L l2 rdr
@@ -77,7 +75,8 @@
   -> TransformT m (LPat GhcPs)
 substPat ctxt (dLPat -> Just p@(L l1 (VarPat x _vl@(L l2 v)))) = fmap cLPat $
   case lookupHoleVar v ctxt of
-    Just (HolePat pA) -> do
+    Just (HolePat pA') -> do
+      let pA = fmap makeDeltaAst pA'
       -- lift $ liftIO $ debugPrint Loud "substPat:HolePat:p" [showAst p]
       -- lift $ liftIO $ debugPrint Loud "substPat:HolePat:pA" [showAst pA]
       p' <- graftA (unparenP <$> pA)
@@ -100,12 +99,17 @@
   -> TransformT m (LHsType GhcPs)
 substType ctxt ty
   | Just (L _ v) <- tyvarRdrName (unLoc ty)
-  , Just (HoleType tyA) <- lookupHoleVar v ctxt = do
+  , Just (HoleType tyA') <- lookupHoleVar v ctxt = do
+    let tyA = fmap makeDeltaAst tyA'
     -- lift $ liftIO $ debugPrint Loud "substType:HoleType:ty" [showAst ty]
     -- lift $ liftIO $ debugPrint Loud "substType:HoleType:tyA" [showAst tyA]
-    ty' <- graftA (unparenT <$> tyA)
-    ty0 <- transferEntryAnnsT isComma ty ty'
-    parenifyT ctxt ty0
+    ty0 <- graftA (unparenT <$> tyA)
+    let hasCs = hasComments ty0
+    ty1 <- if hasCs
+             then return ty0
+             else transferEntryDP ty ty0
+    ty2 <- transferEntryAnnsT isComma ty ty1
+    parenifyT ctxt ty2
 substType _ ty = return ty
 
 -- You might reasonably think that we would replace the RdrName in FunBind...
@@ -117,9 +121,12 @@
 #if __GLASGOW_HASKELL__ < 900
   -> HsMatchContext RdrName
   -> TransformT m (HsMatchContext RdrName)
-#else
+#elif __GLASGOW_HASKELL__ < 910
   -> HsMatchContext GhcPs
   -> TransformT m (HsMatchContext GhcPs)
+#else
+  -> HsMatchContext (LIdP GhcPs)
+  -> TransformT m (HsMatchContext (LIdP GhcPs))
 #endif
 substHsMatchContext ctxt (FunRhs (L l v) f s)
   | Just (HoleRdr rdr) <- lookupHoleVar v ctxt =
diff --color -urN retrie-1.2.3/Retrie/Types.hs /retrie-1.2.3/Retrie/Types.hs
--- retrie-1.2.3/Retrie/Types.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Types.hs	2024-08-30 16:14:52.380653557 +0200
@@ -3,6 +3,7 @@
 -- This source code is licensed under the MIT license found in the
 -- LICENSE file in the root directory of this source tree.
 --
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE DeriveDataTypeable #-}
 {-# LANGUAGE DeriveFunctor #-}
 {-# LANGUAGE FlexibleContexts #-}
@@ -107,17 +108,21 @@
 data Query ast v = Query
   { qQuantifiers  :: Quantifiers
   , qPattern      :: Annotated ast
+  , qOrigin       :: SrcSpan -- ^ The original location in the AST of
+                             -- the query. Equivalent to `getLocA
+                             -- qPattern` of the AST before calling
+                             -- `makeDelta` on it.
   , qResult       :: v
   }
 
 instance Functor (Query ast) where
-  fmap f (Query qs ast v) = Query qs ast (f v)
+  fmap f (Query qs ast l v) = Query qs ast l (f v)
 
 instance Bifunctor Query where
-  bimap f g (Query qs ast v) = Query qs (fmap f ast) (g v)
+  bimap f g (Query qs ast l v) = Query qs (fmap f ast) l (g v)
 
 instance (Data (Annotated ast), Show ast, Show v) => Show (Query ast v) where
-  show (Query q p r) = "Query " ++ show q ++ " " ++ showAst p ++ " " ++ show r
+  show (Query q p l r) = "Query " ++ show q ++ " " ++ showAst p ++ showGhc l ++ " " ++ show r
 
 
 ------------------------------------------------------------------------
@@ -130,11 +135,17 @@
 -- See Note [AlphaEnv Offset] for details.
 
 instance Semigroup (Matcher a) where
+#if __GLASGOW_HASKELL__ < 910
   (<>) = mappend
+#else
+  (Matcher m1) <> (Matcher m2) = Matcher (I.unionWith mUnion m1 m2)
+#endif
 
 instance Monoid (Matcher a) where
   mempty = Matcher I.empty
+#if __GLASGOW_HASKELL__ < 910
   mappend (Matcher m1) (Matcher m2) = Matcher (I.unionWith mUnion m1 m2)
+#endif
 
 -- | Compile a 'Query' into a 'Matcher'.
 mkMatcher :: Matchable ast => Query ast v -> Matcher v
@@ -183,8 +194,8 @@
 type Rewrite ast = Query ast (Template ast, MatchResultTransformer)
 
 -- | Make a 'Rewrite' from given quantifiers and left- and right-hand sides.
-mkRewrite :: Quantifiers -> Annotated ast -> Annotated ast -> Rewrite ast
-mkRewrite qQuantifiers qPattern tTemplate = Query{..}
+mkRewrite :: Quantifiers -> Annotated ast -> SrcSpan -> Annotated ast -> Rewrite ast
+mkRewrite qQuantifiers qPattern qOrigin tTemplate = Query{..}
   where
     tImports = mempty
     tDependents = Nothing
@@ -217,7 +228,7 @@
 mkLocalRewriter env q@Query{..} =
   mkLocalMatcher env q { qResult = RewriterResult{..} }
   where
-    rrOrigin = getOrigin $ astA qPattern
+    rrOrigin = qOrigin
     rrQuantifiers = qQuantifiers
     (rrTemplate, rrTransformer) = first (fmap inject) qResult
 
diff --color -urN retrie-1.2.3/Retrie/Universe.hs /retrie-1.2.3/Retrie/Universe.hs
--- retrie-1.2.3/Retrie/Universe.hs	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/Retrie/Universe.hs	2024-08-30 16:14:52.380653557 +0200
@@ -12,6 +12,7 @@
 module Retrie.Universe
   ( Universe
   , printU
+  , getLocU
   , Matchable(..)
   , UMap(..)
   ) where
@@ -47,6 +48,12 @@
 exactPrintU (ULType t) = exactPrint t
 exactPrintU (ULPat p) = exactPrint p
 
+getLocU :: Universe -> SrcSpan
+getLocU (ULHsExpr e) = getLocA e
+getLocU (ULStmt s) = getLocA s
+getLocU (ULType t) = getLocA t
+getLocU (ULPat p) = getLocA p
+
 -------------------------------------------------------------------------------
 
 -- | Class of types which can be injected into the 'Universe' type.
diff --color -urN retrie-1.2.3/retrie.cabal /retrie-1.2.3/retrie.cabal
--- retrie-1.2.3/retrie.cabal	2001-09-09 03:46:40.000000000 +0200
+++ /retrie-1.2.3/retrie.cabal	2024-08-30 16:14:52.384653515 +0200
@@ -77,14 +77,14 @@
   build-depends:
     ansi-terminal >= 0.10.3 && < 1.1,
     async >= 2.2.2 && < 2.3,
-    base >= 4.11 && < 4.20,
+    base >= 4.11 && < 4.21,
     bytestring >= 0.10.8 && < 0.13,
     containers >= 0.5.11 && < 0.8,
     data-default >= 0.7.1 && < 0.8,
     directory >= 1.3.1 && < 1.4,
     filepath >= 1.4.2 && < 1.6,
-    ghc >= 9.2 && < 9.9,
-    ghc-exactprint >= 1.5.0 && < 1.9,
+    ghc >= 9.2 && < 9.11,
+    ghc-exactprint >= 1.5.0 && < 1.10,
     list-t >= 1.0.4 && < 1.1,
     mtl >= 2.2.2 && < 2.4,
     optparse-applicative >= 0.15.1 && < 0.19,
