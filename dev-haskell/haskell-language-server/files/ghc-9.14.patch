diff --git a/haskell-language-server.cabal b/haskell-language-server.cabal
index 23260a5393..1b70a9dc86 100644
--- a/haskell-language-server.cabal
+++ b/haskell-language-server.cabal
@@ -353,7 +353,7 @@ library hls-class-plugin
     , deepseq
     , extra
     , ghc
-    , ghc-exactprint  >= 1.5 && < 1.13.0.0
+    , ghc-exactprint  >= 1.5 && < 1.15
     , ghcide          == 2.12.0.0
     , hls-graph
     , hls-plugin-api  == 2.12.0.0
@@ -1628,14 +1637,16 @@ flag stylishHaskell
   manual:      True
 
 common stylishHaskell
-  if flag(stylishHaskell)
+  -- stylish-haskell doesn't support GHC 9.14
+  if flag(stylishHaskell) && !impl(ghc >= 9.14)
     build-depends: haskell-language-server:hls-stylish-haskell-plugin
     cpp-options: -Dhls_stylishHaskell
 
 library hls-stylish-haskell-plugin
   import:           defaults, pedantic, warnings
   -- https://github.com/haskell/stylish-haskell/issues/479
-  if !flag(stylishHaskell)
+  -- stylish-haskell doesn't support GHC 9.14
+  if !flag(stylishHaskell) || impl(ghc >= 9.14)
     buildable: False
   exposed-modules:  Ide.Plugin.StylishHaskell
   hs-source-dirs:   plugins/hls-stylish-haskell-plugin/src
@@ -1653,7 +1664,8 @@ library hls-stylish-haskell-plugin
 
 test-suite hls-stylish-haskell-plugin-tests
   import:           defaults, pedantic, test-defaults, warnings
-  if !flag(stylishHaskell)
+  -- stylish-haskell doesn't support GHC 9.14
+  if !flag(stylishHaskell) || impl(ghc >= 9.14)
     buildable: False
   type:             exitcode-stdio-1.0
   hs-source-dirs:   plugins/hls-stylish-haskell-plugin/test
diff --git a/plugins/hls-alternate-number-format-plugin/src/Ide/Plugin/Literals.hs b/plugins/hls-alternate-number-format-plugin/src/Ide/Plugin/Literals.hs
index c26227d933..3768cb9767 100644
--- a/plugins/hls-alternate-number-format-plugin/src/Ide/Plugin/Literals.hs
+++ b/plugins/hls-alternate-number-format-plugin/src/Ide/Plugin/Literals.hs
@@ -66,17 +66,21 @@ getPattern :: LPat GhcPs -> Maybe Literal
 getPattern (L (locA -> (RealSrcSpan patSpan _)) pat) = case pat of
     LitPat _ lit -> case lit of
         HsInt _ val   -> fromIntegralLit patSpan val
+#if __GLASGOW_HASKELL__ < 913
         HsRat _ val _ -> fromFractionalLit patSpan val
+#endif
         _             -> Nothing
     NPat _ (L (locA -> (RealSrcSpan sSpan _)) overLit) _ _ -> fromOverLit overLit sSpan
     NPlusKPat _ _ (L (locA -> (RealSrcSpan sSpan _)) overLit1) _ _ _ -> fromOverLit overLit1 sSpan
     _ -> Nothing
 getPattern _ = Nothing
 
-fromLit :: HsLit p -> RealSrcSpan -> Maybe Literal
+fromLit :: HsLit GhcPs -> RealSrcSpan -> Maybe Literal
 fromLit lit sSpan = case lit of
         HsInt _ val   -> fromIntegralLit sSpan val
+#if __GLASGOW_HASKELL__ < 913
         HsRat _ val _ -> fromFractionalLit sSpan val
+#endif
         _             -> Nothing
 
 fromOverLit :: HsOverLit p -> RealSrcSpan -> Maybe Literal
diff --git a/plugins/hls-change-type-signature-plugin/src/Ide/Plugin/ChangeTypeSignature.hs b/plugins/hls-change-type-signature-plugin/src/Ide/Plugin/ChangeTypeSignature.hs
index 8b8b7e7d3a..36795e6ddd 100644
--- a/plugins/hls-change-type-signature-plugin/src/Ide/Plugin/ChangeTypeSignature.hs
+++ b/plugins/hls-change-type-signature-plugin/src/Ide/Plugin/ChangeTypeSignature.hs
@@ -42,6 +42,10 @@ import           Development.IDE.Types.Diagnostics (_SomeStructuredMessage)
 import           Generics.SYB                      (extQ, something)
 import           GHC.Tc.Errors.Types               (ErrInfo (..),
                                                     TcRnMessageDetailed (..))
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Tc.Errors.Ppr                 (pprErrCtxtMsg)
+import           GHC.Utils.Outputable              (vcat)
+#endif
 import qualified Ide.Logger                        as Logger
 import           Ide.Plugin.Error                  (PluginError,
                                                     getNormalizedFilePathE)
@@ -61,8 +65,13 @@ data Log
 
 instance Pretty Log where
     pretty = \case
+#if MIN_VERSION_ghc(9,13,0)
+        LogErrInfoCtxt (ErrInfo ctxt _ _) ->
+            fromSDoc (vcat $ map pprErrCtxtMsg ctxt)
+#else
         LogErrInfoCtxt (ErrInfo ctxt suppl) ->
             Logger.vcat [fromSDoc ctxt, fromSDoc suppl]
+#endif
         LogFindSigLocFailure name ->
             pretty ("Lookup signature location failure: " <> name)
         where
@@ -175,7 +184,11 @@ matchingDiagnostic ErrInfo{errInfoContext} =
         unwrapMatch (_, _, _, [name]) = Just name
         unwrapMatch _                 = Nothing
 
+#if MIN_VERSION_ghc(9,13,0)
+        errInfoTxt = printOutputable (vcat $ map pprErrCtxtMsg errInfoContext)
+#else
         errInfoTxt = printOutputable errInfoContext
+#endif
 
 -- | List of regexes that match various Error Messages
 errorMessageRegexes :: [Text]
diff --git a/plugins/hls-change-type-signature-plugin/test/Main.hs b/plugins/hls-change-type-signature-plugin/test/Main.hs
index 72a2ab780e..a3877679d2 100644
--- a/plugins/hls-change-type-signature-plugin/test/Main.hs
+++ b/plugins/hls-change-type-signature-plugin/test/Main.hs
@@ -41,7 +41,7 @@ test :: TestTree
 test = testGroup "changeTypeSignature" [
         testRegexes
         , codeActionTest "TExpectedActual" 4 11
-        , knownBrokenForGhcVersions [GHC96 .. GHC912] "Error Message in 9.6+ does not provide enough info" $
+        , knownBrokenForGhcVersions [GHC96 .. GHC914] "Error Message in 9.6+ does not provide enough info" $
             codeActionTest "TRigidType" 4 14
         , codeActionTest "TRigidType2" 4 8
         , codeActionTest "TLocalBinding" 7 22
diff --git a/plugins/hls-class-plugin/src/Ide/Plugin/Class/CodeAction.hs b/plugins/hls-class-plugin/src/Ide/Plugin/Class/CodeAction.hs
index 3f902ef80c..959da19d3a 100644
--- a/plugins/hls-class-plugin/src/Ide/Plugin/Class/CodeAction.hs
+++ b/plugins/hls-class-plugin/src/Ide/Plugin/Class/CodeAction.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP             #-}
 {-# LANGUAGE GADTs           #-}
 {-# LANGUAGE LambdaCase      #-}
 {-# LANGUAGE OverloadedLists #-}
@@ -225,14 +226,18 @@ signatureToName :: InstanceBindTypeSig -> T.Text
 signatureToName sig = T.drop (T.length bindingPrefix) (printOutputable (bindName sig))
 
 -- Return [groupName text, [(methodName text, signature text)]]
-minDefToMethodGroups :: HscEnv -> TcGblEnv -> Range -> [InstanceBindTypeSig] -> BooleanFormula Name -> [MethodGroup]
+minDefToMethodGroups :: HscEnv -> TcGblEnv -> Range -> [InstanceBindTypeSig] -> ClassMinimalDef -> [MethodGroup]
 minDefToMethodGroups hsc gblEnv range sigs minDef = makeMethodGroup <$> go minDef
     where
         makeMethodGroup methodDefinitions =
             let name = mconcat $ intersperse "," $ (\x -> "'" <> x <> "'") . fst <$> methodDefinitions
             in  (name, methodDefinitions)
 
+#if __GLASGOW_HASKELL__ >= 913
+        go (Var lmn)  = pure $ makeMethodDefinitions hsc gblEnv range $ filter ((==) (printOutputable (unLoc lmn)) . signatureToName) sigs
+#else
         go (Var mn)   = pure $ makeMethodDefinitions hsc gblEnv range $ filter ((==) (printOutputable mn) . signatureToName) sigs
+#endif
         go (Or ms)    = concatMap (go . unLoc) ms
         go (And ms)   = foldr (liftA2 (<>) . go . unLoc) [[]] ms
         go (Parens m) = go (unLoc m)
diff --git a/plugins/hls-class-plugin/test/Main.hs b/plugins/hls-class-plugin/test/Main.hs
index 7f1feddc11..3765ac29fc 100644
--- a/plugins/hls-class-plugin/test/Main.hs
+++ b/plugins/hls-class-plugin/test/Main.hs
@@ -11,6 +11,7 @@ import           Control.Lens                  (Prism', prism', view, (^.),
                                                 (^..), (^?))
 import           Control.Monad                 (void)
 import           Data.Foldable                 (find)
+import qualified Data.List                     as List
 import           Data.Maybe
 import qualified Data.Text                     as T
 import qualified Ide.Plugin.Class              as Class
@@ -109,9 +110,9 @@ codeLensTests = testGroup
             doc <- openDoc "CodeLensSimple.hs" "haskell"
             lens <- getAndResolveCodeLenses doc
             let titles = map (^. L.title) $ mapMaybe (^. L.command) lens
-            liftIO $ titles @?=
-                [ "(==) :: B -> B -> Bool"
-                , "(==) :: A -> A -> Bool"
+            liftIO $ List.sort titles @?=
+                [ "(==) :: A -> A -> Bool"
+                , "(==) :: B -> B -> Bool"
                 ]
     , testCase "No lens for TH" $ do
         runSessionWithServer def classPlugin testDataDir $ do
@@ -129,7 +130,7 @@ codeLensTests = testGroup
             liftIO $ length lens > 0 @?= True
         `catch` \(e :: SessionException) -> do
           liftIO $ assertFailure $ "classPluginTestError: "++ show e
-    , goldenCodeLens "Apply code lens" "CodeLensSimple" 1
+    , goldenCodeLens "Apply code lens" "CodeLensSimple" 0
     , goldenCodeLens "Apply code lens for local class" "LocalClassDefine" 0
     , goldenCodeLens "Apply code lens on the same line" "Inline" 0
     , goldenCodeLens "Don't insert pragma while existing" "CodeLensWithPragma" 0
@@ -155,7 +156,7 @@ goldenCodeLens :: TestName -> FilePath -> Int -> TestTree
 goldenCodeLens title path idx =
     goldenWithHaskellDoc def classPlugin title testDataDir path "expected" "hs" $ \doc -> do
         lens <- getAndResolveCodeLenses doc
-        executeCommand $ fromJust $ (lens !! idx) ^. L.command
+        executeCommand $ fromJust $ (List.sort lens !! idx) ^. L.command
         void $ skipManyTill anyMessage (message SMethod_WorkspaceApplyEdit)
 
 goldenWithClass ::TestName -> FilePath -> FilePath -> ([CodeAction] -> Session CodeAction) -> TestTree
diff --git a/plugins/hls-eval-plugin/src/Ide/Plugin/Eval/Handlers.hs b/plugins/hls-eval-plugin/src/Ide/Plugin/Eval/Handlers.hs
index 1f19b5b476..6aa3b94dad 100644
--- a/plugins/hls-eval-plugin/src/Ide/Plugin/Eval/Handlers.hs
+++ b/plugins/hls-eval-plugin/src/Ide/Plugin/Eval/Handlers.hs
@@ -87,6 +87,12 @@ import           Data.List.Extra                              (unsnoc)
 import           Development.IDE.Core.PluginUtils
 import           Development.IDE.Types.Shake                  (toKey)
 import           GHC.Types.SrcLoc                             (UnhelpfulSpanReason (UnhelpfulInteractive))
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Types.Avail                              (DetOrdAvails (DefinitelyDeterministicAvails),
+                                                               sortAvails)
+import           GHC.Tc.Types                                 (tcg_exports)
+import           GHC.Types.Name.Set                           (nameSetElemsStable)
+#endif
 import           Ide.Logger                                   (Priority (..),
                                                                Recorder,
                                                                WithPriority,
@@ -262,11 +268,12 @@ initialiseSessionForEval needs_quickcheck st nfp = do
     -- it back to the iface for the current module.
     tm <- tmrTypechecked <$> use_ TypeCheck nfp
     let rdr_env = tcg_rdr_env tm
-    let linkable_hsc = loadModulesHome (map (addRdrEnv . linkableHomeMod) linkables) deps_hsc
         addRdrEnv hmi
           | iface <- hm_iface hmi
           , ms_mod ms == mi_module iface
-#if MIN_VERSION_ghc(9,11,0)
+#if MIN_VERSION_ghc(9,13,0)
+          = hmi { hm_iface = set_mi_top_env (IfaceTopEnv (sortAvails $ gresToAvailInfo $ globalRdrEnvElts $ globalRdrEnvLocal rdr_env) (mkIfaceImports $ tcg_import_decls tm)) iface}
+#elif MIN_VERSION_ghc(9,11,0)
           = hmi { hm_iface = set_mi_top_env (Just $ IfaceTopEnv (forceGlobalRdrEnv (globalRdrEnvLocal rdr_env)) (mkIfaceImports $ tcg_import_decls tm)) iface}
 #else
           = hmi { hm_iface = iface { mi_globals = Just $!
@@ -277,12 +284,20 @@ initialiseSessionForEval needs_quickcheck st nfp = do
                 }}
 #endif
           | otherwise = hmi
-
+#if MIN_VERSION_ghc(9,13,0)
+    linkable_hsc <- liftIO $ loadModulesHome (map (addRdrEnv . linkableHomeMod) linkables) deps_hsc
+#else
+    let linkable_hsc = loadModulesHome (map (addRdrEnv . linkableHomeMod) linkables) deps_hsc
+#endif
     return (ms, linkable_hsc)
   -- Bit awkward we need to use evalGhcEnv here but setContext requires to run
   -- in the Ghc monad
   env2 <- liftIO $ evalGhcEnv env1 $ do
+#if MIN_VERSION_ghc(9,13,0)
+            setContext [Compat.IIModule (ms_mod ms)]
+#else
             setContext [Compat.IIModule (moduleName (ms_mod ms))]
+#endif
             let df = flip xopt_set    LangExt.ExtendedDefaultRules
                    . flip xopt_unset  LangExt.MonomorphismRestriction
                    . flip gopt_set    Opt_ImplicitImportQualified
@@ -296,7 +311,14 @@ initialiseSessionForEval needs_quickcheck st nfp = do
             getSession
   return env2
 
-#if MIN_VERSION_ghc(9,11,0)
+#if MIN_VERSION_ghc(9,13,0)
+mkIfaceImports :: [ImportUserSpec] -> [IfaceImport]
+mkIfaceImports = map go
+  where
+    go (ImpUserSpec decl ImpUserAll) = IfaceImport decl ImpIfaceAll
+    go (ImpUserSpec decl (ImpUserExplicit avails parents)) = IfaceImport decl (ImpIfaceExplicit (DefinitelyDeterministicAvails avails) (nameSetElemsStable parents))
+    go (ImpUserSpec decl (ImpUserEverythingBut ns)) = IfaceImport decl (ImpIfaceEverythingBut (nameSetElemsStable ns))
+#elif MIN_VERSION_ghc(9,11,0)
 mkIfaceImports :: [ImportUserSpec] -> [IfaceImport]
 mkIfaceImports = map go
   where
@@ -463,10 +485,18 @@ evals recorder mark_exception fp df stmts = do
             dbg $ LogEvalFlags flags
             ndf <- getInteractiveDynFlags
             dbg $ LogEvalPreSetDynFlags ndf
+#if MIN_VERSION_ghc(9,13,0)
+            hsc_env <- getSession
+            eans <-
+                liftIO $ try @GhcException $
+                parseDynamicFlagsCmdLine (hsc_logger hsc_env) ndf
+                    (map (L $ UnhelpfulSpan unhelpfulReason) flags)
+#else
             eans <-
                 liftIO $ try @GhcException $
                 parseDynamicFlagsCmdLine ndf
                 (map (L $ UnhelpfulSpan unhelpfulReason) flags)
+#endif
             dbg $ LogEvalParsedFlags eans
             case eans of
                 Left err -> pure $ Just $ errorLines $ show err
diff --git a/plugins/hls-eval-plugin/test/Main.hs b/plugins/hls-eval-plugin/test/Main.hs
index 03416c6902..c00b6fcab7 100644
--- a/plugins/hls-eval-plugin/test/Main.hs
+++ b/plugins/hls-eval-plugin/test/Main.hs
@@ -133,6 +133,7 @@ tests =
   , knownBrokenInWindowsBeforeGHC912 "The output has path separators in it, which on Windows look different. Just skip it there" $
       goldenWithEvalAndFs' "Property checking with exception" cabalProjectFS "TPropertyError" "hs" $
         case ghcVersion of
+          GHC914 -> "ghc914.expected"
           GHC912 -> "ghc912.expected"
           GHC910 -> "ghc910.expected"
           GHC98  -> "ghc98.expected"
diff --git a/plugins/hls-eval-plugin/test/testdata/TPropertyError.ghc914.expected.hs b/plugins/hls-eval-plugin/test/testdata/TPropertyError.ghc914.expected.hs
new file mode 100644
index 0000000000..46359c86ab
--- /dev/null
+++ b/plugins/hls-eval-plugin/test/testdata/TPropertyError.ghc914.expected.hs
@@ -0,0 +1,6 @@
+-- Support for property checking
+module TProperty where
+
+-- prop> \(l::[Bool]) -> head l
+-- *** Failed! Exception: 'Prelude.head: empty list' (after 1 test):
+-- []
diff --git a/plugins/hls-explicit-fixity-plugin/src/Ide/Plugin/ExplicitFixity.hs b/plugins/hls-explicit-fixity-plugin/src/Ide/Plugin/ExplicitFixity.hs
index 92bc37f743..af17f47096 100644
--- a/plugins/hls-explicit-fixity-plugin/src/Ide/Plugin/ExplicitFixity.hs
+++ b/plugins/hls-explicit-fixity-plugin/src/Ide/Plugin/ExplicitFixity.hs
@@ -75,8 +75,10 @@ instance Show FixityMap where
 instance NFData FixityMap where
   rnf (FixityMap xs) = rnf xs
 
+#if __GLASGOW_HASKELL__ < 913
 instance NFData Fixity where
   rnf = rwhnf
+#endif
 
 newtype Log = LogShake Shake.Log
 
diff --git a/plugins/hls-gadt-plugin/src/Ide/Plugin/GHC.hs b/plugins/hls-gadt-plugin/src/Ide/Plugin/GHC.hs
index f5687a9db3..0042936e31 100644
--- a/plugins/hls-gadt-plugin/src/Ide/Plugin/GHC.hs
+++ b/plugins/hls-gadt-plugin/src/Ide/Plugin/GHC.hs
@@ -117,6 +117,9 @@ h98ToGADTConDecl dataName tyVars ctxt = \case
 #endif
             -- Ignore all existential type variable since GADT not needed
             implicitTyVars
+#if MIN_VERSION_ghc(9,13,0)
+            []  -- con_inner_bndrs (new in 9.13)
+#endif
             (mergeContext ctxt con_mb_cxt)
             (renderDetails con_args)
             renderResultTy
@@ -125,19 +128,17 @@ h98ToGADTConDecl dataName tyVars ctxt = \case
     where
         -- Parameters in the data constructor
         renderDetails :: HsConDeclH98Details GP -> HsConDeclGADTDetails GP
-#if MIN_VERSION_ghc(9,9,0)
+#if MIN_VERSION_ghc(9,13,0)
+        renderDetails (PrefixCon args)     = PrefixConGADT noExtField args
+        renderDetails (InfixCon arg1 arg2) = PrefixConGADT noExtField [arg1, arg2]
+        renderDetails (RecCon recs)        = RecConGADT NoEpUniTok recs
+#elif MIN_VERSION_ghc(9,9,0)
         renderDetails (PrefixCon _ args)   = PrefixConGADT noExtField args
-#else
-        renderDetails (PrefixCon _ args)   = PrefixConGADT args
-#endif
-#if MIN_VERSION_ghc(9,9,0)
         renderDetails (InfixCon arg1 arg2) = PrefixConGADT noExtField [arg1, arg2]
-#else
-        renderDetails (InfixCon arg1 arg2) = PrefixConGADT [arg1, arg2]
-#endif
-#if MIN_VERSION_ghc(9,9,0)
         renderDetails (RecCon recs)        = RecConGADT NoEpUniTok recs
 #else
+        renderDetails (PrefixCon _ args)   = PrefixConGADT args
+        renderDetails (InfixCon arg1 arg2) = PrefixConGADT [arg1, arg2]
         renderDetails (RecCon recs)        = RecConGADT recs noHsUniTok
 #endif
 
@@ -257,12 +258,10 @@ prettyGADTDecl df decl =
 #endif
 
 #if MIN_VERSION_ghc(9,11,0)
-        adjustDefnWhere annDataDefn
-          | andd_where annDataDefn == NoEpTok = annDataDefn
-          | otherwise = annDataDefn {andd_where = andd_where'}
-          where
-            (EpTok (EpaSpan aw)) = andd_where annDataDefn
-            andd_where' = EpTok (EpaDelta aw (SameLine 1) [])
+        adjustDefnWhere annDataDefn = case andd_where annDataDefn of
+            NoEpTok -> annDataDefn
+            EpTok (EpaSpan aw) -> annDataDefn {andd_where = EpTok (EpaDelta aw (SameLine 1) [])}
+            EpTok (EpaDelta {}) -> annDataDefn  -- already adjusted
 #endif
         -- Remove the first extra line if exist
         removeExtraEmptyLine s = case stripInfix "\n\n" s of
diff --git a/plugins/hls-overloaded-record-dot-plugin/src/Ide/Plugin/OverloadedRecordDot.hs b/plugins/hls-overloaded-record-dot-plugin/src/Ide/Plugin/OverloadedRecordDot.hs
index 8ead286b67..f2f71956b8 100644
--- a/plugins/hls-overloaded-record-dot-plugin/src/Ide/Plugin/OverloadedRecordDot.hs
+++ b/plugins/hls-overloaded-record-dot-plugin/src/Ide/Plugin/OverloadedRecordDot.hs
@@ -47,7 +47,11 @@ import           Development.IDE.GHC.Compat           (Extension (OverloadedReco
                                                        getLoc, hs_valds,
                                                        parenthesizeHsExpr,
                                                        pattern RealSrcSpan,
-                                                       unLoc)
+                                                       unLoc
+#if __GLASGOW_HASKELL__ >= 913
+                                                       , unLocWithUserRdr
+#endif
+                                                       )
 import           Development.IDE.GHC.Util             (getExtensions,
                                                        printOutputable)
 import           Development.IDE.Graph                (RuleResult)
@@ -300,14 +304,22 @@ getRecSels e@(unLoc -> HsApp _ se@(unLoc -> HsRecSel _ _) re) =
       | RealSrcSpan realSpan' _ <- [ getLoc e ] ], False )
 -- Record selection where the field is being applied with the "$" operator:
 -- "selector $ record"
-#if __GLASGOW_HASKELL__ >= 911
+#if __GLASGOW_HASKELL__ >= 913
+getRecSels e@(unLoc -> OpApp _ se@(unLoc -> XExpr (HsRecSelRn _))
+                        (unLoc -> HsVar _ (unLocWithUserRdr -> d)) re) | d == dollarName =
+    ( [ RecordSelectorExpr (realSrcSpanToRange realSpan')  se re
+      | RealSrcSpan realSpan' _ <- [ getLoc e ] ], False )
+#elif __GLASGOW_HASKELL__ >= 911
 getRecSels e@(unLoc -> OpApp _ se@(unLoc -> XExpr (HsRecSelRn _))
+                        (unLoc -> HsVar _ (unLoc -> d)) re) | d == dollarName =
+    ( [ RecordSelectorExpr (realSrcSpanToRange realSpan')  se re
+      | RealSrcSpan realSpan' _ <- [ getLoc e ] ], False )
 #else
 getRecSels e@(unLoc -> OpApp _ se@(unLoc -> HsRecSel _ _)
-#endif
                         (unLoc -> HsVar _ (unLoc -> d)) re) | d == dollarName =
     ( [ RecordSelectorExpr (realSrcSpanToRange realSpan')  se re
       | RealSrcSpan realSpan' _ <- [ getLoc e ] ], False )
+#endif
 getRecSels _ = ([], False)
 
 collectRecSelResult :: MonadIO m => IdeState -> NormalizedFilePath
diff --git a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction.hs b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction.hs
index 1fba6b67e5..9f57bb185a 100644
--- a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction.hs
+++ b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction.hs
@@ -1872,11 +1872,11 @@ extractQualifiedModuleName x
 --         ‘Data.Functor’ nor ‘Data.Text’ exports ‘putStrLn’.
 extractDoesNotExportModuleName :: T.Text -> Maybe T.Text
 extractDoesNotExportModuleName x
-  | Just [m] <- case ghcVersion of
-                  GHC912 -> matchRegexUnifySpaces x "The module ‘([^’]*)’ does not export"
-                            <|> matchRegexUnifySpaces x "nor ‘([^’]*)’ export"
-                  _ ->      matchRegexUnifySpaces x "the module ‘([^’]*)’ does not export"
-                            <|> matchRegexUnifySpaces x "nor ‘([^’]*)’ export"
+  | Just [m] <- if ghcVersion >= GHC912
+                  then matchRegexUnifySpaces x "The module ‘([^’]*)’ does not export"
+                       <|> matchRegexUnifySpaces x "nor ‘([^’]*)’ export"
+                  else matchRegexUnifySpaces x "the module ‘([^’]*)’ does not export"
+                       <|> matchRegexUnifySpaces x "nor ‘([^’]*)’ export"
   = Just m
   | otherwise
   = Nothing
diff --git a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs
index bffd2a611c..f46f2571d5 100644
--- a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs
+++ b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/CodeAction/ExactPrint.hs
@@ -43,7 +43,11 @@ import           GHC                                    (AnnContext (..),
                                                          IsUnicodeSyntax (NormalSyntax),
                                                          NameAdornment (NameParens),
                                                          TrailingAnn (AddCommaAnn),
-                                                         emptyComments, reAnnL)
+                                                         emptyComments
+#if !MIN_VERSION_ghc(9,13,0)
+                                                        , reAnnL
+#endif
+                                                        )
 
 
 -- See Note [Guidelines For Using CPP In GHCIDE Import Statements]
@@ -66,6 +70,13 @@ import           GHC                                    (NoAnn (..))
 import           GHC                                    (EpAnnComments (..))
 #endif
 
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC                                    (spanAsAnchor)
+
+reAnnL :: ann -> EpAnnComments -> Located e -> GenLocated (EpAnn ann) e
+reAnnL anns cs (L l a) = L (EpAnn (spanAsAnchor l) anns cs) a
+#endif
+
 ------------------------------------------------------------------------------
 
 -- | Construct a 'Rewrite', replacing the node at the given 'SrcSpan' with the
diff --git a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/AddArgument.hs b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/AddArgument.hs
index aec82cb17f..e316dc005e 100644
--- a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/AddArgument.hs
+++ b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/AddArgument.hs
@@ -49,6 +49,11 @@ import           Language.Haskell.GHC.ExactPrint           (d1, setEntryDP)
 import           GHC.Parser.Annotation                     (EpToken (..))
 #endif
 
+#if MIN_VERSION_ghc(9,13,0)
+-- HsArrow was renamed to HsMultAnn in GHC 9.13
+type HsArrow pass = HsMultAnn pass
+#endif
+
 -- When GHC tells us that a variable is not bound, it will tell us either:
 --  - there is an unbound variable with a given type
 --  - there is an unbound variable (GHC provides no type suggestion)
@@ -177,7 +182,15 @@ hsTypeFromFunTypeAsList (args, res) =
 addTyHoleToTySigArg :: Int -> LHsSigType GhcPs -> LHsSigType GhcPs
 addTyHoleToTySigArg loc (L annHsSig (HsSig xHsSig tyVarBndrs lsigTy)) =
     let (args, res) = hsTypeToFunTypeAsList lsigTy
-#if MIN_VERSION_ghc(9,9,0)
+#if MIN_VERSION_ghc(9,13,0)
+        wildCardAnn = noAnnSrcSpanDP1
+        newArg =
+          ( noAnn
+          , noExtField
+          , HsUnannotated (EpArrow (EpUniTok d1 NormalSyntax))
+          , L wildCardAnn $ HsWildCardTy NoEpTok
+          )
+#elif MIN_VERSION_ghc(9,9,0)
         wildCardAnn = noAnnSrcSpanDP1
         newArg =
           ( noAnn
diff --git a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/FillTypeWildcard.hs b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/FillTypeWildcard.hs
index 0f06fff2f7..43a0c246cc 100644
--- a/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/FillTypeWildcard.hs
+++ b/plugins/hls-refactor-plugin/src/Development/IDE/Plugin/Plugins/FillTypeWildcard.hs
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 module Development.IDE.Plugin.Plugins.FillTypeWildcard
   ( suggestFillTypeWildcard
   ) where
@@ -14,6 +15,10 @@ import           Development.IDE.Types.Diagnostics (_SomeStructuredMessage)
 import           GHC.Tc.Errors.Types               (ErrInfo (..))
 import           Language.LSP.Protocol.Types       (Diagnostic (..),
                                                     TextEdit (TextEdit))
+#if MIN_VERSION_ghc(9,13,0)
+import           GHC.Tc.Errors.Ppr                 (pprErrCtxtMsg)
+import           GHC.Utils.Outputable              (vcat)
+#endif
 
 suggestFillTypeWildcard :: FileDiagnostic -> [(T.Text, TextEdit)]
 suggestFillTypeWildcard diag@FileDiagnostic{fdLspDiagnostic = Diagnostic {..}}
@@ -83,9 +88,13 @@ diagErrInfoContext diag = do
                 . _TcRnMessageWithCtx
                 . _TcRnMessageWithInfo
     let TcRnMessageDetailed err _ = detailedMsg
+#if MIN_VERSION_ghc(9,13,0)
+        ErrInfo errInfoCtx _ _ = err
+    Just (printOutputable (vcat $ map pprErrCtxtMsg errInfoCtx))
+#else
         ErrInfo errInfoCtx _ = err
-
     Just (printOutputable errInfoCtx)
+#endif
 
 -- | Detect whether user wrote something like @foo :: _@ or @foo :: Maybe _@.
 -- The former is considered toplevel case for which the function returns 'True',
diff --git a/plugins/hls-refactor-plugin/test/Main.hs b/plugins/hls-refactor-plugin/test/Main.hs
index 0fb8b61f83..42cea85818 100644
--- a/plugins/hls-refactor-plugin/test/Main.hs
+++ b/plugins/hls-refactor-plugin/test/Main.hs
@@ -3379,7 +3379,9 @@ addSigActionTests = let
     executeCodeAction chosenAction
     modifiedCode <- documentContents doc
     liftIO $ expectedCode @=? modifiedCode
-  issue806 = if ghcVersion >= GHC910 then
+  issue806 = if ghcVersion >= GHC914 then
+                  "hello = print"           >:: "hello :: GHC.Internal.Types.ZonkAny 0 -> IO ()" -- GHC 9.14 moved to GHC.Internal.Types
+                else if ghcVersion >= GHC910 then
                   "hello = print"           >:: "hello :: GHC.Types.ZonkAny 0 -> IO ()" -- GHC now returns ZonkAny 0 instead of Any. https://gitlab.haskell.org/ghc/ghc/-/issues/25895
                 else
                   "hello = print"           >:: "hello :: GHC.Types.Any -> IO ()" -- Documents current behavior outlined in #806
diff --git a/plugins/hls-refactor-plugin/test/Test/AddArgument.hs b/plugins/hls-refactor-plugin/test/Test/AddArgument.hs
index a0bf8b004e..d612e356f1 100644
--- a/plugins/hls-refactor-plugin/test/Test/AddArgument.hs
+++ b/plugins/hls-refactor-plugin/test/Test/AddArgument.hs
@@ -34,8 +34,8 @@ tests =
       mkGoldenAddArgTest "AddArgWithSigAndDocs" (r 8 0 8 50),
       mkGoldenAddArgTest "AddArgFromLet" (r 2 0 2 50),
       mkGoldenAddArgTest "AddArgFromWhere" (r 3 0 3 50),
-      -- TODO can we make this work for GHC 9.10?
-      knownBrokenForGhcVersions [GHC910, GHC912] "In GHC 9.10 and 9.12 end-of-line comment annotation is in different place" $
+      -- TODO can we make this work for GHC 9.10+?
+      knownBrokenForGhcVersions [GHC910, GHC912, GHC914] "In GHC 9.10+ end-of-line comment annotation is in different place" $
           mkGoldenAddArgTest "AddArgFromWhereComments" (r 3 0 3 50),
       mkGoldenAddArgTest "AddArgWithTypeSynSig" (r 2 0 2 50),
       mkGoldenAddArgTest "AddArgWithTypeSynSigContravariant" (r 2 0 2 50),
